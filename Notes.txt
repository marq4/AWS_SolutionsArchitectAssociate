* Course: SAA-S03. 
* Exam Domains. Design $ Architecture:
	+ Secure. 
	+ Resilient. 
	+ High-Performing. 
	+ Cost-Optimized. 


____________________________________ S3 _______________________________________

* Unlimited object storage. 
* Serverless. 
* Object: 						// Concurrent connections: simultaneous request of multiple parts of an object. 
	- Key (name): value (data). 
	- Version. 
	- Metadata. 
* Buckets: 
	- Unlike IAM Policies, which are attached to AWS users, Resource Policies are applied to the resource (bucket), rules can be added for anonymous/public users. 
	- Hold objects (and simulate /folders/). 
	- Naming: 
		' Similar to (and used in) URLs. 
		' 3-63 chars long. 
		' lowercase numbers . - 				# No .. 
		' Must begin and end with alphanumeric. 
		' No IP format. 
		' Invalid prefixes: xn--, sthree-config. 
		' Invalid postfixes: -s3alias. 
	- Restrictions: 
		' 100 buckets. SR: 1,000. 
		' Use multi-part upload for files > 100MB. Process: create-multipart-upload, get Upload_ID, upload-part ..., complete-multipart-upload (provide json with etags). // Parts can be numbered 1..1000. 
	- Types: 
		' General Purpose: 
			; Flat. 
			; Cannot be used with S3 Express One Zone storage class. 
		' Directory: 
			; Only for S3 Express One Zone storage class. 
			; Single-digit millisecond performance on PUT and GET. 
			; Limit: 10. 
	- Objects: 
		' Resources that represent data, not infra. 
		' Etags (entity tags): to tell if content changed. Part of HTTP protocol. Used by caching systems. Hash of the object contents (not metadata). 
		' Locking: make immutable. 
		' Checksums: ensure integrity of a file. 
		' Metadata: 
			; System defined: 
				` Content Type (I can modify it). 
				` Cache Control. 
				` Content Disposition. 
				` Content-Encoding.  
				` Content-Language. 
				` Expires. 
				` X-amz-website-redirection-location. 
			; User defined: 
				` Prefix: x-amz-meta- 
		' WORM: Write Once Read Many. 
		' Lock: prevent deletion. Must be specified at creation time. Only programmatically. 
			; Retention period. 
			; Legal hold. 
		' URI: s3://. 
		' CLI: 						// $ aws configure set region 
			; s3. 
			; s3api 
			; s3control: access points. 
			; s3outposts 
		' Requests: 
			; Virtual hosted. 
			; Path-style. 
		' Storage Classes: 				// Provide varying level of Data Access, Resiliency, Cost. 
			; Durability: 99.999999999% 
			; Standard (default): fast, available, durable. 
				` Availability: 99.99% 			// Replicated accross 3 AZs. 
				` Retrieval: milliseconds. 
				` Throughput: frequently or real-time access. 
				` Pricing per: GB, request. 			// I can make object publicly available. 
			; Reduced Redundancy Storage (RRS): legacy. 
				` Noncritical data. Not recommended. 
			; Intelligent Tiering: uses ML, extra fee to analyze. 
				` Auto: frequent. 
				` If not accessed in 30 days: infrequent. 
				` 90 days: Archive Instant. 
				` Optional: Archive Access. 
				` Optional: Deep Archive. 
				` At least 30 days. 
			; Express One-Zone: single-digit ms perf, half price than Standard. 
				` Delivers consistent single-digit millisecond data access. 
				` For: most frequently accessed data, latency-sensitive apps. 
				` Lowest latency. 10x faster than Standard. 
				` 50% cheaper than Standard. 
				` Stored in Directory bucket. 
			; Standard-IA (Infrequent Access): fast, cheaper if access < once/month. 
				` Availability: 99.9%. 
				` Disaster recovery, backups, long-term. 
				` Retrieval fee. 					// Retrieval: milliseconds. 
				` Min 30 days. 
				` 3 or more AZs. 
				` Min 128KB per object. 
			; One-Zone IA. Data CAN be lost. 
				` Availability: 99.5%. 
				` 20% cheaper than Standard-IA. 
				` Retrieval: milliseconds. 
				` For: backup on-prem data, data than can be recreated if AZ disaster, non-mission crtitical. 
				` Pricing: per GB, per request, retrieval fee, min 30 days, min 128 KB per object. 
			; Glacier-Instant (Retrieval): long-term cold storage. Get data instantly. 
				` Rarely accessed data. 
				` Availability: 99.9%. 
				` 68% cheaper than Standard-IA. 
				` For: data accessed one per quarter. Use cases: image hosting, online file-sharing apps, medical imaging, health records, news media assets, satellite imaging. 
				` Retrieval: milliseconds. 
				` Pricing: per GB, per request, higher retrieval fee, min 90 days. 
				` NOT VAULT. 
			; Glacier Flexible: 						// Cannot be publicly available. 
				` Retrieval Tiers: 
					° Expediated: 1-5m, Lim: 250MB. 
					° Standard: 3-5h, default. 
					° Bulk: 5-12h. 
				` Pricing: per GB retrieved, number of requests, storage. 
				` Min 40 KB per object, min 90 days. 
				` I should store fewer and larger files due to the 40KB overhead. 
				` NOT VAULT. 
			; Glacier Deep Archive: 12h. 				// Cheapest. Can't be publicly available. 
				` Retrieval Tiers: 
					° Standard: 12-48h, default. 
					° Bulk: 12-48h. 
				` More expensive retrieval fee. 
				` Min: 180 days. 
				` NOT VAULT. 
			; Outposts. 

* Range: 0B to 5TB. 
* Glacier: "Vault". 
	+ Deep Archive. 

* Security: 							// Block IP: policy statement with "Effect": "Deny". 
	+ Bucket Policies: bucket-level permissions, JSON access policy. 	// Determines WHO. 
		- Principal: users. 
		- Resources: what. 
		- Effect: allow | deny. 
		- Action. 
	+ ACL (Access Control Lists): legacy, not recommended. 
		- Grant basic r/w. 
		- To other accounts. 
	+ Internetwork Traffic Privacy.
		- PrivateLink (VPC Interface Endpoint [connect VPC to AWS services using PrivateLink]): 
			` Private netw access. 
			` Connect an ENI (Elastic Netw Interface) directly to other services, 3rd parties, accounts. 
			` Fine-grain permissions. 
		- VPC GW Endpoint: 
			' Free. 
			' Reliable connectivity to S3 and DynamoDB (without IGW, NAT). 
	+ CORS (Cross-Origin Resource Sharing): 
		- HTTP-header based mechanism allows a server to let other origins load resources. 
	+ Block Public Access: 
		- New ACLs. 
		- Any ACLs. 
		- New Bucket Policies or Access Points. 
		- Any Bucket Policies or Access Points. 
	+ IAM Access Analyzer. 
		- Alerts me if my bucket is exposed to the internet. 
		- I must first create an analyzer at account level. 
	+ Object Ownership. 
	+ Access Points: named netw endpoints that are attached to buckets. 
		- Netw origins: Internet | VPC. 
	+ Access Grants: 
		- Map identities in a Directory Service such as Active Directory. 
		- Access Grants Instance: logical container. 
	+ Versioning: preserves, retrieves, restores. 
	+ MFA Delete. 
	+ Object Tags: organize. 
	+ In-Transit Encryption: over internet. 
	+ Server-Side Encryption: 
		- Always on by default. 
		- SSE-S3: AES-GCM 256-bit. 			// AWS auto rotates regularly. 
		- SSE-KMS: I manage the keys and use Key Mgmt Service. For compliance. Required: kms:GenerateDataKey permission. 
		- SSE-C (Customer): I manage and provide the keys. 
			` AES256. 
			` AWS does not hold on to my key but they store a salted Hash-based Message Authentication Code (HMAC). 
		- DSSE-KMS: Dual-layer server-side (also enc at client side). 		// Generates a DEK. 
	+ Client-Side Encryption: TLS 1.3. 
		- When I encrypt my files before uploading them to S3. 
	+ Compliance Validation. 
	+ Infra Security. 
	+ Bucket Key: 
		' When SSE-KMS. 
		' When SSE-S3. 
		' Generates a short-lived bucket-level key. 
	+ Data Consistency: 
		' Strongly Consistent: they will never return old data to me, but I must wait 2 seconds to get it. 
		' Eventually Consistent: they will give me the data currently available immediately, and after 2 seconds it will generally be up to date. 
		' As of Jan 2020, S3 offers strong consistency for all r,w,d operations. 
	+ How do I give access to an AWS user to my bucket: 
		' Bucket policies work together with IAM policies. 
	+ How do I allow public users access to my bucket? 
		' Use a bucket Policy. 

* Object Replication: 
	+ Cross-Region. 						// Data sync: S3 Replication Rules. 
	+ Same-Region. 
	+ Bi-Directional. 
	+ Batch (on-demand). 
	+ Cross-Account: secure data sharing enhancing collaboration and data management. 

* Versioning: 
	+ Recover more easily from unintended accidental delete/overwrite and failures. 
	+ States: 
		- Unversioned. 
		- Versioned. 
		- (Versioning) Suspended. 

* Transfer Acceleration: 								// Using CloudFront (S3OriginConfig). 
	+ Fast & secure transfer of files over long distances to my customers (bucket-level). 	// use_accelerate_endpoint 
	+ Using CloudFront's distributed Edge Locations. 
	+ Distinct endpoint: https://s3-accelerate (.dualstack = for also IPv6). 
	+ Only for virtual-hosted style requests. 
	+ Bucket names = no dots (.). 

* Presigned URLs: programmatically and temporarily provide access to upload/download objects (commonly private). 
	+ $ aws s3 presign s3://bucket/object --expires-in <SECONDS> 
	+ X-Amz-Date: timestamp signature created. 

* Object Lambda Access Points: allows me to transform the output of S3 requests to present data differently. 
	+ HEAD, GET, LIST. 

* Mountpoint for S3: 
	+ Mount an S3 bucket to my local Linux fs for high-throughput. 
	+ CAN: read, list, create new files. 
	+ CANNOT: modify files, delete dirs, symlinks, file locking. 
	+ Storage Classes: Standard, IA, One-Zone IA, RRS, Glacier Instant. 

* Archived Objects: 
	+ Rarely accessed, not in real-time. 
	+ Archive Storage Classes: I manually move data. Glacier Flexible, Deep. 
	+ Archive Acces Tiers: automatically. Intelligent-Tiering Archive access: minutes. Intelligent-Tiering Deep: 12+h. 

* Requesters pay: 					// Share valuable data without incurring the costs associated with data access, as researchers and users cover their own S3 usage fees. 
	+ I (owner) pay for storage. 
	+ Requesters pay for download. 		$  --request-payer 
	+ Header: x-amz-request-payer. 
	+ Not allowed: SOAP requests. 

* Batch Operations: 					// Provide: list of objects in an S3 bucket | Inventory report manifest.json. 
	+ Only for ClickOps. 
	+ Billions of objects containing exabytes of data. 
	+ Operations for each object: 
		- Copy (to another bucket). 
		- Invoke Lambda. 
		- Replace tags. 
		- Replace ACL. 
		- Restore (from Glacier). 
		- Lock retention. 
		- Lock legal hold. 

* Inventory: scheduled for audit history. 
	- Daily or weekly. 
	- I can specify metadata. 
	- Report output formats: CSV, ORC, Parquet. 

* S3 Event Notifications: allows a bucket to notify other services about S3 events. 		// At least one, seconds. 

* Storage Class Analysis: analyze access patterns and recommend objects to move between Standard and IA. 
	+ Up to 1,000 analysis filters per S3 bucket. 

* Lens: storage analysis tool for buckets. 
	+ Data can be exported: CSV, Parquet -> another bucket | CloudWatch. 

* Static Website Hosting: 
	+ NO HTTPS! 
	+ Or redirect requests to objects. 

* Byte Range Fetching: to download parts of a file




* CLI:
	+ High level: 						$ aws s3 
	+ Low level: 						$ aws s3api 
	+ Best region for me: us-east-2 (Ohio). 

* Bash: 
	+ Get jq: 							$ choco install jq 

* PowerShell: 
	+ Install AWS CLI for PowerShell: 			$ Install-Module -Name AWS.Tools.Installer 
	+ Install S3 module: 				$ Install-AWSToolsModule AWS.Tools.S3 
	// Note: I couldn't manage to install AWS-S3 powershell module. 

* SDK: 
	+ Ruby: 
		- Ruby file extention: .rb. 
		- Package manager: bundler. 
		- Install ruby: 				https://rubyinstaller.org/downloads/ 	; 	Re-open VS Code. 
		- Create gem file: 				$ bundle init 
		- Download gems: 				$ bundle install 
		- Run program: 				$ BUCKET_NAME='marq----ruby-bucket' bundle exec ruby s3.rb 

	+ Java: 
		- Developer tools website: 			https://aws.amazon.com/products/developer-tools/

	+ Python: 
		- pip install boto3

	+ IaC: 
		- CloudFormation (CFN). 
			' S3: 
				; The region of the bucket will be the same as the stack. To create a bucket in another region, specify it (--region) during the `aws cloudformation deploy` command. 
				; To configure it so I have to manually accept the changeset use option: --no-execute-changeset. 
				; To accept the changes on the Console: CloudFormation > Stacks > <STACK> > Change sets > <CHANGE_SET> > review the changes > Execute change set. 
		- Terraform: Advantages: multi-cloud. 
			' S3: the content of the files (objects) is not tracked. We can use etag argument for that use case. 
		- CDK (Cloud Development Kit): programming language code to CloudFormation. 
		- Pulumi. 

########################################################






















_____________________________________ API _____________________________________

* An Application Programming Interface allows 2 apps/services to communicate. 
* The most common type is HTTP(S) requests. 

* CLI: processes commands to a computer program as lines of text. 
* Terminal: text only interface. 
* Console: physical computer to input into a terminal. 
* Shell: command-line program to input commands. 

* AWS Credentials: key and secret. 					// AWS_ACCESS_KEY_ID 

* Exponential Backoff: to try again in 2 sec, 4, 8, 16, 32 ...			// To handle network failures more efficiently. 

* STS (Security Token Service): temporary, limited-privilege credentials. 
	+ Call returns: AccessKeyID, SecretAccessKey, SessionToken, and Expiration. 

* When using API directly (HTTP) I must sign the request. 

* Service Endpoints: to connect programmatically I use an endpoint. An endpoint is the URL of the entry point for a service. 
	+ Gobal. 
	+ Regional. 
	+ FIPS. 
	+ Dualstack. 

* Custom Domains: allows setting up custom domains. 

########################################################







_____________________________________ VPC _____________________________________		// Shared?: check OwnerID. 

* Virtual Private Cloud: logically isolated virtual network. 
	+ Region specific. 
	+ CIDR block: range of IP addresses assigned to it. Size: from /16 to /28. 
	+ I can create 5 VPCs per region (or request more). 
	+ Every region comes with a default VPC. 
		- IPv4 CIDR block: 172.31.0.0/16 (~65,536). 
		- A (public) subnet (/20) for each AZ (4,096). 
		- IGW. 
		- SG. 
		- NACL. 
		- DHCP. 
		- A Route Table with a route out to the internet via IGW. 
	+ Up to 200 subnets. 
	+ 5 IPv4 CIDR blocks (adjustable to 50). 
	+ 5 IPv6 CIDR blocks (adjustable to 50). 

* Core components: 
	+ IGW (Internet Gateway): enables resources to connect to the internet. 
		- Attach to a VPC. Are region resilient. 
		- A VPC can have max 1 IGW. IGW can be attached to max 1 VPC. 
		- A subnet is made public once a default route points to the IGW. 
		- How to make subnet public: 
			` Create IGW. 
			` Attach it to VPC. 
			` Create custom route table. 
			` Configure default route. 
			` Associate subnet with RT. 
		- Allows inbound and outbound internet traffic to my VPC. 
		- I need a route for IPv4 (0.0.0.0/0) and another for IPv6 (::/0). 
		- Performs NAT for instances with public IPs. 
	+ VGW (Virtual Private Gateway): to a private external netw. 		// Endpoint into my AWS account for a VPN connection. 
	+ Route Tables. 
		- Each subnet must be implicitly or explicitly associated with a SINGLE RT. 
		- Multiple subnets can share the same RT. 
		- MAIN RT: default. Cannot be deleted. 
		- Target: local, IGW, VPG (to on-prem), NAT GW (IPv4 only), Egress-Only IGW, EC2 Instance, ENI, Carrier GW, Core Netw (to WAN), GW LB (for virtual appliances), Outpost Local GW, Peering Connection, TGW (Transit Hub). 
	+ NAT GW: allows my private instances (VMs) to connect to services outside the VPC. 	// If I need to gain outbound access to the internet from my private netw, to re-map the private IPs. 
		- So my internal instance in a private subnet can download patches from the internet. 
		- IGW is still needed. 
		- Gets deployed in a particular PUBLIC subnet/AZ. 
		- Per subnet. Costs per hour and per GB of data transfered. 
		- Bandwidth: 5 Gbps. Auto scales up to 100 Gbps. 
		- Must associate EIP address. 
		- Private connection mode: instances in private subnets to other VPCs or on-prem. 
		- How to allow a private instance to download SW packages from the internet: 
			` Public RT: 0.0.0.0/0 -> IGW. Associate with public subnet. 
			` Deploy NAT GW to the public subnet. Allocate an EIP. 
			` Private RT: 0.0.0.0/0 -> NAT GW. Associate with private subnet. 
		- In production I would deploy multiple NAT GWs in different AZs. 
	+ NACLs (Netw Access Control Lists): stateless virtual firewall at subnet level. 
		- Allow & deny rules. 
	+ Security Groups (SG): stateful virtual firewall for compute within a VPC, instance level. 
		- Stateful firewalls are aware of requests' state. Allow all outbound requests, and their responses. 
		- Associated with EC2 instances. 
		- Allow rules only. 
		- Up to 10,000 per region (default 2,500). 
		- Rules: 60 outbound, 60 inbound. 
		- 16 per ENI (default 5). 
		- Always allowed: 
			' Amazon DNS. 
			' Amazon DHCP. 
			' EC2 instance metadata. 
			' Windows Licenses. 
			' Amazon Time Sync service. 
			' Reserved IPs by the default VPC route. 
	+ Public subnets. 
	+ Private subnets. 
	+ VPC Endpoints: privately connect my VPC to AWS support services. 
		- Types: 
			` Interface. 
			` GW. 
			` GWLB. 
	+ VPC Peering: to other VPCs.  
		- Direct netw route with private IPs. 
		- Accross accounts and regions. 
		- Star configuration. 
		- Won't work if overlapping CIDR blocks. 
		- $: Data transfer accross AZs/Regions. 


* Subnet: a group of IP addresses in a VPC. 
	+ Resides within a single AZ. 
	+ Public | Private. 						// Determined by GWs. 
	+ Block size: /16 - /28. 
	+ First 4, and last IPs are reserved: 
		- 0: Netw address. 
		- 1: VPC Router. 
		- 2: DNS. 
		- 3: future use. 
		- 255: Broadcast. 
	+ Cannot overlap in same VPC. 
	+ Optional /26 IPv6 CIDR. 

* Routing: 
	+ Every VPC has a VPC router: route traffic between subnets & I/O VPC. 
		- The router has an interface in every subnet (netw+1 address). 
	+ Route Table: set of rules the router uses to forward traffic (each rule = route). 
		- All RTs have exactly 1 route by default: local. 
	+ Every subnet is associated with 1 Route Table (Default by default). 
	+ Multiple subnets can share a RT. 


* DNS: 
	+ Device private IPs will auto get DNS entry. 
	+ DNS server can be accessed via second IP of CIDR block and 169.254.169.253. 
	+ enableDnsHostnames. 
	+ enableDnsSupport. 

* Share VPCs (subnets) across accounts: 
	+ Same region. 
	+ With Resource Access Manager (RAM). 

* Gateway (GW): 
	+ Netw services that sits between 2 different networks. 
	+ Often act as reverse proxies, FW, LB. 

* EO-IGW: for IPv6 to prevent inbound traffic from the internet. 

* Elastic IPs (EIP): static IPv4 address. 
	+ Associated to Instance or primary network card. 
	+ Associate to EC2 instance: $ aws ec2 associate-address 
	+ $: additionals per hour. 
	+ Region specific. 
	+ Allocate to account > associate. 

* Direct Connect: 
	+ On-prem: Customer GW -> DX (Direct Connect Location) Customer router -Cross connect-> AWS router -> VPGW / AWS public services. 
	+ Establish dedicated network connections from on-premises locations to AWS. 
	+ Pricing factors: 
		- Capacity. 
		- Port hours. 
		- Data Transfer Out (DTO). 

* Private Link (PrivateLink): to securely connect my VPC to: supported services, services hosted on other accounts, supported Marketplace partners (without the need of IGW, NAT, VPN, Direct Connect). 
	+ Interface (ENI) endpoint -> Service endpoint (Netw LB). 
		- Interface Endpoint: ENI with a private IP address. Costs money. 		// Primary use case: private connection to AWS services, partner services, and other VPCs without public IPs. 
			' To connect my VPC to AWS services using AWS PrivateLink. 
	+ Access SaaS privately. 
	+ GWLB Endpoint: to distribute traffic to a fleet for netw virtual appliances. 

* VPC Flow logs: capture IP traffic information. 
	+ For VPC, subnets, netw if. 

* AWS VPN: to establish a secure and private tunnel from my network or device to AWS global network. 
	+ Site-To-Site: VPC to on-prem. 
		- VGW (Virtual Private GW): VPN endpoint (Amazon side) attached to a single VPC. 
			' Assign an ASN (Autonomous System Number). 
			' $: for each available VPN connection hour + data transfer out from EC2. 
			' Max bandwith: 1.25 Gbps per tunnel, 140,000 packets, MTU: 1,466 b. 
		- Customer GW (CGW): 
			' Provides info to AWS about my device. 
			' Configure my device: 
				` IKE. 
				` IPsec. 
				` Tunnel Interface. 
				` BGP. 
		- Transit GW: for IPv6. 				// Netw transit hub to interconnect VPCs+on-prem netws. 
			' Allow for transitive routing. 
			' I must specify one subnet from each AZ to be used by the Transit GW to route traffic. 
			' Can peer to other TGWs cross-region, cross-account. 
			' Virtual router at region level. 
			' Attach up to 5,000 VPCs. An ENI provisioned for each. 
			' Also for Direct Connect. 
			' Also for third-party virtual appliances. 
			' Each attachment can handle up to 50 Gbps of traffic. 
	+ Client VPN (laptop): to securely connect to RDS instance that is on a private subnet. 
		- Fully managed client-based VPN service to securely access AWS/on-prem resources. 
	+ How to connect my on-prem resources to my VPC: 
		- Deploy VPGW on AWS side. 
		- Deploy Customer GW on the on-prem side. 
		- Both get a public IP address. 
		- IPsec tunnel connects them through the internet. 
		- For routing, 2 options: 
			` Static: manually define route in RT to VPGW. 
			` Dynamic: config dynamic routing proto: BGP. 


* NAT (Network Address Translation): mapping IP address space into another by modifying IP header of packets in transit accross traffic-routing device. 
	- Instances: NAT in an EC2 for scaling. 		// Legacy service to launch NAT on EC2 that requires ME to handle scaling. 

* Bastion / Jumpbox: security hardened VM that provides secure access to private subnets. AWS alternative: Sessions Manager. 

* VPC Lattice: to turn my AWS resources into services for a micro-service architecture. 
	+ Service Network: logical container for these services (communicating to each other) in the associated VPCs. 
	+ Listener(s): up to 2. 
	+ Target group: of specific type. 
	+ Service Directory. 

* Traffic Mirroring: sends a copy of the packet from src ENI to: target ENI, UDP-enabled NLB/GWLB. 
	+ For security monitoring/analysis. 
	+ Attaches additional VXLAN header. 
	+ Src, target, filters. 

* Route 53 Resolver DNS Firewall: protects agains DNS exfiltration. 

* Network Firewall: stateful, managed, and IDS/IPS (Intrusion Detection/Protection) for VPC. 
	+ Traffic that can filter: IGW, NAT GW, VPN. 
	+ Endpoints: entry and exit points, in its own Firewall subnet. 
	+ Rule groups. 
	+ Rule sync. 
	+ I have to set up the Route Tables. 
	+ Alternative deployment: Transit GW. 
	+ Rules Engines: Stateless | Stateful. 

* Network Address Usage (NAU): metric. Default limit: 64,000. Quota increase: 256,000. 
	+ Metric applied to resources in my virtual network to plan for and monitor the size of my VPC. 

########################################################













____________________________________ IAM ____________________________________

* Manages access of AWS users and resources. 
* Policies: 
	+ AWS managed. 
	+ Customer managed. 
	+ In-line. 
* Principal: account, user, role, federated user. 
* Effect: allow/deny. 
* Use root account to:
	+ Change account settings. 
	+ Close AWS account. 
	+ Change/cancel support plan. 
* Cross Account Role: sts:AssumeRole. 
* Via web id provider: I send an OAuth 2.0 request to Facebook -> it responds with a Javascript Web Token -> aws CLI AssumeRoleWebIdentity -> STS -> I get temp creds. 
* SSO: allows a user to login with a single ID/passw to different systems. 
* Access key: Access Key ID + Secret Access Key. 
* Statement container: allows for multiple occurrences and serves as a container for policy statements. 
* ConsoleMe: OSS Netflix project. Provides self-service capabilities for managing permissions. 

* Identity Center (SSO): manage users for multiple accounts. 
	+ Permission Set: collections of IAM policies. 


########################################################










____________________________________ EC2 ____________________________________

* Highly configurable virtual server with resizable compute capacity. Takes minutes to launch. 
* Cloud-init: industry standard multi-distribution method for cross-platform cloud instance initialization. 
	+ Cloud instances are init from a disk image and instance data: 
		- Meta data: MDS (Metadata Service) special endpoint: 169.254.169.254 | fd00:ec2::254 
			` Categories. 
			` Configuration: 
				' Enforce use of tokens (use v2 of MDS). 
			` $ curl http://169.254.169.254/latest/meta-data/ 
		- User data: my script to run when instance boots up. 
		- Vendor data. 

* Instance Types: Family Generation Processor-Family Additional-Capabilities . Size 
	+ The 6 types: General Purpose, Optimized: Compute, Mem, Accel, Storage, HPC. 
	+ Instance Family: combinations of CPU, Memory, Storage, Netw capacity. 		// M (General Purpose): even balance. T (Burstable perf): cheapest. Variable workloads. 
		' General Purpose: 
			` A1, T2, T3, T3a, T4g, M4, M5, M5a, M5n, M6zn, M6g, Mgi, Mac. 
			` Web servers, code repos. 
		' Compute Optimized: 
			` C5, C4, Cba, C5n, C6g, C6gn. 
			` Scientific modeling, dedicated gaming servers, ad server engines. 
		' Memory Optimized: 
			` R4, R5, R5a, R5b, R5n, X1, X1e, High Memory, z1d. 
			` In-memory caches, in-mem DBs, real time big data analytics. 
		' Accelerated Optimized: 
			` P2, P3, P4, G3, G4ad, G4dn, F1, Inf1, VT1. 
			` Machine Learning, computational finance, seismic analysis, speech recognition. 
		' Storage Optimized: 
			` I3, I3en, D2, D3, D3en, H1. 
			` NoSQL, In-mem transactional DBs, Data Warehousing. 

* Processors: 
	+ Intel Xeon. 
	+ AMD EPYC. 
	+ NVIDIA GPUs. 
	+ AWS Graviton: ARM arch. 
	+ Intel Habana Gaudi: ML. 
	+ Intel FPGAs: HW accel. 
	+ AMD Xilinx. 
	+ AWS Inferentia. 
	+ Trainium. 

* Sizes: generally double in price and key attributes. 

* Profile: reference to IAM role assumed by the instance. 

* Lifecycle: 
	+ Actions: 
		- Launch: create and start. 
		- Stop: turn off. 
		- Start: turn on. 
		- Terminate: delete. 
		- Reboot: soft. 
		- Retire: notify is scheduled for retirement. 
		- Recover: a failed instance on new HW. 
	+ States: 
		- Pending: preparing to enter running state. 
		- Running: ready for use. 
		- Stopping. 
		- Stopped: shut down. 
		- Shutting-down. 
		- Terminated. 

* Instance Console Screenshot: of the current state. 		$ aws ec2 get-console-screenshot 

* Default user: ssmuser					$ sudo su - ec2-user 

* Burstable Instances (T family): 
	+ Allow workloads to handle bursts of higher CPU usage for very short durations. 
	+ T4g: Gravitron (ARM). 
	+ T3a: AMD EPYC. 
	+ T3: Intel Xeon Scalable. 
	+ T2: Intel Xeon. Free tier. 
	+ Modes: 
		- Standard: using accumulated CPU credits. 
		- Unlimited: additional charges. 

* System Log: directly on the Console. 

* Placement Groups: choose the logical placement to optimize for: communication, performance, durability. 
	+ Free. 
	+ Cluster: AZ. For HPC (High-Performance Computing). 
	+ Partition: rack per partition. For Hadoop. 
	+ Spread: each instance in a different rack. Max 7. 

* EC2 Connect: 
	+ SSH: public + private keys, open port 22 on SG. 
	+ EC2 Instance Connect: short-lived SSH keys controlled by IAM. 
	+ Sessions Manager. 
	+ Fleet Manager Remote Desktop: Windows RDP. 
	+ Serial console: underlying HW. 

* Amazon Linux: based off CentOs. 
	+ Advantages: maintained and hardened by AWS, direct support (or even only option) for services, better technical support. 

* AMI (Amazon Machine Image): provides the info required to launch an instance. 
	+ Region specific. 
	+ I can also turn my instance into an AMI. 
	+ Template for root volume: 
		- EBS Snapshot. 
		- Instance Store template. 
	+ Launch permissions. 
	+ A block device mapping. 
	+ ENA (Elastic Netw Adapter): 100 Gbps. 
	+ Root Device Type: 
		- EBS-backed: storage is independent of the instance. 
		- Store-backed: native volumes. 			// All data lost when instance is stopped/terminated. 
	+ Create AMI: $ aws ec2 create-image 
		- Running or stopped. 
		- I can copy an AMI to another region. 
	+ Store & Restore: storing (or restoring from) an AMI in an S3 bucket, to copy from one partition to another. 
		- $ aws ec2 create-instance-export-task 
		- $ aws ec2 import-image 
	+ Deregister. 
	+ Deprecate. 
	+ Disable. 
	+ Share: public, explicit, implicit. 
	+ Can be sold in Marketplace. 
	+ Virtualization types: 
		- HVM (Hardware VM): preferred. 
		- PV (Paravirtualization). 
	+ Image Builder: 
		- Golden Image. 
		- Choose Base Image > Add/remove SW > Customize settings > Test > Distribute > Run. 
		- Pipeline: Build > Infra config > Distribution config. 
		- Automate image creation, version mgmt. 

* ASG (Auto Scaling Groups): contains a collection of EC2 instances treated as a group for automatic (horizontal) scaling and management. 
	+ Automatic scaling: 
		- Capacity settings: manual. Min, Max, Desired.  
		- Health Check Replacements: checks: EC2, ELB. 
			' An ELB (Elastic Load Balancer) can be attached to the ASG indirectly via Target Groups. 
		- Dynamic Scaling Policies: how much ASG should change capacity, triggered by Cloud Watch Alarms. 
			' Simple: by a certain ammount. Not recommended. 			// Key component: Scaling Adjustment. 
			' Step: by a certain ammount at different thresholds (steps) when the alarm is repeatedly triggered. 
			' Target Tracking: automatically scales the capacity based on a target metric value. 
				` Metrics: AvgCPU, AvgNetwIn/Out, ALBRequestCountPerTarget, Custom. 
				` Will create 2 CloudWatch alarms. 
			' Predictive: triggers scaling by analyzing historical load data to detect daily or weekly patterns in traffic flows. 
				` Requires 24h CloudWatch data. 
				` Modes: Forecast Only | Forecast & Scale. 
				` Steps: Analyze historical load -> Generate forecast -> Schedule scaling actions based on the forecast. 
			' Adjustment types for Simple and Step: ChangeInCapacity, ExactCapacity, PercentChangeInCapacity. 
	+ Works with ECS and EKS. 
	+ Fargate DOES NOT USE ASG.  


* Pricing: 
	+ On-Demand: 	// Least Commitment. Short-term or irregular workloads. 
		- Pay per hour. 
		- Spiky. 
	+ Spot: 		// Save up to 90% $. 
		- Spare computing capacity from AWS. 
		- Flexible start/end times. 
		- Must handle interruptions. 
		- Use case: non-critical bg jobs, batch processing. 
	+ Reserved:	// Long-Term commitment with discount. 
		- Steady usage. 
		- 1 or 3 years. 
		- Term x Class Offering x RI attrs x Payment Option. 
			' Class: Standard (can be brought | sold), Convertible. 
			' Attrs: Instace type, Region, Tenancy, Platform. 
			' Scope: Regional | Zonal (AZ). 
			' Limits: per month: 20 regional, 20 per AZ. 
		- Factors: type, region, tenancy, platform. 
	+ Dedicated: on-demand, reserved, spot. 	// Most expensive. 
		- Host: Same physical host. 		// Re-use licenses. 
		- Instance: physical host can change but exclusive for me. 
	+ Saving Plans: simplifies the purchasing process. 	// Predictable workloads. 
		- Compute. 
		- Instance. 
		- SageMaker.			// Notebook: Fully managed instance to create, edit, share Jupyter notebooks for data exploration, analysis, ML model building. 

* Capacity Reservation: request a reserve of EC2 instance type for a specific Region and AZ. 
* Source/destination check: restricts an instance to only send and receive traffic where it is the source or the destination, enhancing security. 
* Logs can be delivered to CloudWatch Logs by installing the CloudWatch Unified agent on the EC2 instance. 

* Elastic Network Interface (ENI): 
	+ Multiple IPs. 
	+ Primary ENI: eth0, private IP. Cannot be detached. 			// Auto created by default. 
	+ Secondary ENIs. 
	+ EIPs. 
	+ Assign SGs. 
	+ Hot attach/detach. 
	+ Netw Flow Logs. 

########################################################


* ELB (Elastic Load Balancer): 
	+ Load Balancer: accepts incoming traffic and then ditributes it to mutiple targets. Balance the load via rules. 
	+ ELB: suite of LBs for EC2, ECS, Fargate, EKS instances. 
	+ ALB (Application): OSI layer 7 (HTTP(S)). Can only be accessed via hostname. Use cases: microservices, containerized apps, e-commerce, retail websites, corporate websites, web apps, SaaS apps. 
		- Request Routing: add rules to a listener (HTTP). 
	+ NLB (Network): OSI layer 3/4 TCP/UDT. Can handle millions of requests per second. Use cases: high-perf computing, Big Data apps, real-time & multiplayer gaming platforms, IoT, telecommunication networks. 
	+ GWLB (Gatway): to virtual appliances. 
	+ CLB (Classic): OSI layer 7, 3/4. No recommended. 
	+ Rules: Listeners > Rules (ALB only) > Target Groups. 
	+ To associate ALB|NLB with EC2 instances: Target Groups. 
	+ To enable load balancing between 2 webservers: 
		- Place EC2 instances in private subnet(s). 
		- Create a Target Group and associate the instances. 
		- Create an ALB that forwards HTTP/80 traffic to that TG. 



* Route 53: 							// Implement complex traffic flows (Blue/Green, failover). 
	+ DNS (Domain Name Service). 
	+ Register and manage domains. 
	+ Hosted Zones: container for record sets, scoped to route traffic for a domain or subdomains. 
		- Public: inbound traffic from the Internet. 
		- Private: within a VPC. 
	+ Record sets: always changed in batch via API. 			// UPSERT. 
		- Alias Target can point to: CloudFront, Elastic Beanstalk, ELB, S3 website endpoint, resource record set (www.example.com), VPC endpoint, APIGW endpoint custom regional API. 
		- TTL: how long DNS info should be cached. 
	+ Traffic Flow: visual editor. 
		- Versioning: roll out/back updates. 
	+ Routing policies: 
		- Simple (default): 1 record -> multiple IPs (random order). 
		- Weighted: split traffic. 
		- Latency-based: lowest netw latency based on region. 		// Requires: Latency Resource Record on EC2/ELB in each region. 
		- Failover: active/passive setups (PRIMARY/SECONDARY). 
		- Geolocation: customer. 
		- Geo-proximity: resources. Must use Traffic Flow tool. 
		- Multi-value Answer: automatic health checks. 
	+ Health checks: every 30 seconds (can be reduced to 10s). 
	+ Resolver: DNS server that allows me to resolve DNS queries between on-prem and VPC. 
	+ DNSSEC (Domain Name Service Security Extensions): suite of specifications by the IETF for securing data exchange in DNS in IP networks. 
		- Recommended to prevent others to impersonate my domain. 
		- Signing. 
		- It ensures DNS responses are authentic and have not been tampered with, providing an additional layer of security. 
	+ Zonal Shift: capability in Route 53 App Recovery Controller (ARC) to shift a LB away from a failed AZ to a healthy one in a single action. 
	+ Profiles: across VPCs and accounts. 
		- Resources: 
			' Private hosted zones. 
			' Route 53 Resolver rules. 
			' DNS Firewall rule groups. 
	+ To use geoproximity routing policy: Traffic Flow.  
	+ Application Recovery Controller (ARC): service that continously monitors my app's ability to recover from failures. 
		- Cell: groups all resources required for an app to operate independently. 
		- Recovery Group: collection of cells that represents an app that I want to check for failover readiness. 
		- Resource Set: AWS resources that can span multiple cells. 
		- Readiness Checks: monitor readiness of standby deployment. 
		- Routing Control: allows me to manually failover entire app stack to standby site. 


* Global Accelerator: to find the optimal path from the end user to my web-server through AWS backbone. 
	+ Routing users to edge locations to get to the AWS netw as soon as possible. 
	+ Deployed within Edge Locations. 
	+ Types: 
		' Standard. 
		' Custom Routing: to specific EC2 instances. 


* CloudFront: 
	+ CDN (Content Delivery Netw): distributed netw of servers that delivers web pages and content to users based on their geo location, the origin of the web page, and the server. 
	+ CloudFront delivers: 
		' Static content. 
		' Dynamic content. 
		' Streaming videos. 
		' Web sockets. 
	+ Components: 
		' Origin. 
		' Regional caches. 
		' Distribution: Web, RTMP (streaming). 			// TTL default: 24h. I can manually invalidate the cache at the distribution level (/*, /dir/*, /specific-object). 
		' Edge Locations. 
	+ Lambda@Edge: 
		' Viewer request/response. 
		' Origin request/response. 
	+ Functions: lightweight edge functions. Cheaper, faster, but more limited. 	// JavaScript 5.1. 
		' Viewer request. 
		' Viewer response. 
	+ Origin: the source where CloudFront will send requests. 
		' Domain name. 
		' Path. 



* EBS (Elastic Block Storage): highly available and durable solution for attaching persistent block storage volumes to an EC2 instance. 
	+ IOPS (I/O per second): speed at which non-contiguous reads and writes and be performed on a storage medium. 
	+ Throuput: data transfer rate to & from the storage medium in MB per second. 
	+ Bandwidth: measurement of total possible speed of data movement along the netw. 
	+ Automatically replicated within their AZ. 
	+ Types: 
		' General Purpose SSD (gp2). 
		' gp3: 20% lower cost. Max: 16K IOPS. 								// Most workloads. 
		' Provisioned IOPS SSD (io1): fast. Perf: >16k IOPS. Size: 4GiB - 16 TiB. Max: 64k IOPS. 			// Critical, IOPS intensive, Throughput-intensive. 
		' io2 Block Expresss: higher throughput, IOPS and storage. Perf: > 64k | 1k MiB/s. Size: 4GiB - 64 TiB. Max: 256k IOPS. 
		' Cold HDD (sc1): infrequent access. 
		' Throughput Optimized HDD (st1): magnetic drive quick throughput. Use cases: Log Processing, Big Data WH. 
		' Magnetic (standard): previous generation HDD. 
	+ HDD RAID (Redundant Array of Independent Disks): virtual data storage to improve fault tolerance. 		// Actuator arm: moves R/W head to correct position on platters. 
		' RAID 0 (Striping): no redundancy. 
		' RAID 1 (Mirroring): data is duplicated. 
		' RAID 5 (Parity): at least 3 disks. 
		' RAID 6 (Double): survives failure of 2 disks. 
		' RAID 10: 1+0. 
	+ SSD (Solid State Drive): integrated circuit assemblies using flash memory. 
		' Types: SATA, NVMe, M.2, U.2, Portable, PCIe. 
		' M.2: commonly used in laptops/compact PCs. Interfaces: SATA, NVMe. 
	+ How can I make an EBS volume available to an instance that's in ANOTHER AZ: 
		' Take a snapshot of the EBS volume (S3). 
		' Deploy a new EBS volume in the other AZ. 
		' Attach this new volume to the instance in the other AZ. 
	+ How about to another region: 
		' Create a snapshot of the EBS volume (S3). 
		' Copy the snapshot to the other region (S3). 
	+ When would I need to use io2 express: 
		' Latency: sub-millisecond. IOPS: 64,000. Throughput: 1,000 MiB/s. Volume size: 64TiB. 
	+ What is the best option for Big Data, Data Warehousing, Log processing: 
		' Throughput Optimized HDD (st1). 

* Instance Storage: instance store provides temporary block storage physically attached to host computer for scratch data. 


* EFS (Elastic File System): file storage service for EC2 instances. 
	+ Storage capacity grows up to PB and shrinks automatically based on data stored. 
	+ Multiple EC2 instances in the same VPC can mount a single EFS volume. 
	+ Uses Netw File System version 4 protocol (NFSv4). 			// Linux only. 
	+ Create multiple mount targets in all subnets. 
	+ To identify netw fs: netdev. 
	+ EFS fs is made availble inside a VPC via mount target. 
	+ Mount target gets IP from its subnet. 
	+ Storage classes: Standard, One-Zone. 
	+ Modes: general purpose perf, elastic throughput. 


* FSx: to deploy scale feature-rich, high-performance FSs in the cloud. 			// Supports various fs protocols. 
	+ NetApp ONTAP. 
	+ OpenZFS. 
	+ WFS (Windows File Server). On-prem access: VPN, Direct Connect. 		// Fully managed shared storage solution built on Windows Server with native Windows compatibility, enterprise performance, and consistent sub-millisecond latencies. 
	+ Lustre. 
	+ File Cache: temporary high-perf storage location. 			// Makes dispersed datasets available to file-based applications on AWS with a unified view and at high speeds—sub-millisecond latencies and high throughput. 


* Backup: centrally manage backups accross AWS services. 
	+ Plan (or on-demand). 
	+ Vault. 
		' Lock: Governance mode: exceptions. Compliance mode: data can't be altered during retention period. 
	+ Recovery Point. 
	+ Incremental. 
	+ Immutable. 



* Snow Family: storage (and compute) devices used to physically move data in/out of the cloud. 
	+ Delivered to S3. 
	+ Snowcone: portable, rugged. 			// For edge computing, data transfer. 
		' Physically shipping | DatSync. 
		' 8TB (HDD). 
		' 14 TB (SSD). 
	+ Snowball Edge: more local processing, edge-computing workloads, config options. 
		' LCD display. 
		' Can cluster 3 - 16 nodes. 
		' Config options: 
			` Storage-optimized (data transfer): 80TB. 
			` Storage-optimized: 210TB. 
			` Storage-optimized EC2-compatible compute: 80TB, 40 vCPUs, 80 GB RAM. 
			` Compute optimized: 28 TB NVMe SSD, 104 vCPUs, 416GB RAM. 
			` Compute optimized with GPU: equivalent to P3. 
		' Data transfer protos: NFSv3, NFSv4, NFSv4.1, Amazon S3 over HTTP or HTTPS. 
	+ Snowmobile: 100 PB. 



* Transfer: managed transfer of files over FTP, SFTP, FTPS, AS2. 		// Fully managed HA FTP server to host files. 
	+ To: S3, EFS. 

* Migration Hub: single place to discover my existing servers, plan migrations, track status.
	+ Monitor status of: 
		- AMS/MGN (Application Migration Service): actual migration from on-prem to AWS. 90d free. Create migration plans. Replication & continous data sync. Automated Cutover & testing. 	// Also from another Cloud provider, between regions, AZ, account. 
		- DMS (Database Migration Service): quickly & securely migrate a DB to another. Example: on-prem to AWS. 
			' DMS Fleet Advisor: Data Collector -> S3 -> DMS. 
			' AWS Schema Conversion: automatically converts src DB schema to target DB schema. 
			' AWS Schema TOOL: desktop app. 
			' Each migration path requires research as NOT all combinations of src/target are possible. 
			' Migration methods: homogenous, instance replication, serverless. 
			' Replication Instance. 
			' DMS Endpoint: source, type, server name, port, creds. 
			' Replication Task: Full Load, Full Load + CDC, CDC Only. 
			' Homogenous | Heterogenous. 
	+ Discovery Agent. 
	+ Migration Evaluator Collector: submit request to AWS to assess a migration. 
	+ Refactor: bridges networking accross AWS accounts so legacy and new services can communicate. 
	+ Journey: guided templates for end-to-end migrations. 
* App Discovery Service: gathers info about apps & infra to plan migration. 
	+ Dependency mapping. 
	+ Methods: 
		- Agents: collect data on netw traffic, processes, perf, config of servers. 
		- Agentless: VMware with Agent runnin on it. Collect info on CPU, RAM, DB metadata. 
	+ Data collected pushed every 15m via TLS secure tunnel to S3. 

* Mainframe Modernization: move mainframe app from on-prem to AWS. 
	+ Refactoring: legacy -> modern. Code & data. Blu Age: inventory analysis, dependency analysis, automated code transformation, scenario capture and mgmt. 
	+ Replatforming. 
	+ Asses. 
	+ Developer IDE. 
	+ CI/CD. 




* Data Sync (DataSync): data transfer service for data migration to/from/between Cloud Storage services. 
	+ Components: 
		- Agent. 
		- Location. 
		- Task: available, running, unavailable, queued. 
		- Task Execution. 
	+ Protocols: NFS, SMB, HDFS, Object Storage. 
	+ AWS: S3, EFS, FSx, Snowcone, S3-Compatible Snowball Edge. 
	+ External: Google Cloud Storage, Azure Blob Storage & Files, OCI Object Storage, IBM Cloud Object Storage. 




* Auto Scaling: service that discovers scaling resources in my account to add scaling plans. 
	+ Can manage and make recommendations for: EC2, ECS, Aurora, DynamoDB, Spot Fleet. 
	+ Apply SCALING: Dynamic | Predictive. 

* Amplify: JS framework and managed infra to develop web/mobile apps. 
	+ Components: CLI, SDK, UI, Hosting, Studio. 


* App Flow (AppFlow): managed integration service for data transfer between data sources. 	// Fully managed integration service to securely exchange data between SaaS apps & AWS services. 
	+ Flow triggers: RUN on: demand, event, schedule. 
	+ Use cases: 
		- Transfer Salesforce oportunities -> RedShift records. 
		- Analyze Slack conversations on schedule. 
		- Manually trigger flow for tickets with a common case # in Zendesk -> S3. 


* App Sync (AppSync): fully managed GraphQL service. 
	+ Data Model, Data Sources, Resolvers. 
	+ API types: GraphQL, Merged. 
	+ Data sources: DynamoDB Table, OpenSearch, etc. 
	+ Caching: none, full request, per-resolver. 
	+ GraphQL: open-source agnostic query adaptor to query data from different data sources. 

* AWS Batch: plans, schedules, executes batch computing workloads. 
	+ Jobs, definitions, queues, scheduler (FIFO default). 
	+ Runs on: EC2, Fargate, EKS. 

* OpenSearch Service: full-text search service to deploy, operate, scale OpenSearch. 
	+ Engines: 
		- OpenSearch: AWS's fork. 
			' OpenSearch Ingestion. 
			' Service Domains. 
			' Up tp 3 PB. 
			' Use cases: monitor apps, SIEM, Personalized Search. 
			' Serverless. 
			' Domain = Cluster. 
		- ElasticSearch: based on Lucene library. ELK stack: ElasticSearch, Logstash, Kibana. 

* Device Farm: to test my app in different environments like Mobile Device and Desktop Browser. 

* Amazon Quantum Ledger Database (QLDB): fully managed ledger DB for transparent, immutable, cryptographically variable txn logs. 
	+ Immutable logs. 
	+ Crytographic verification. 
	+ Serverless. 
	+ SQL-like queries. 
	+ Central Governance. 
	+ High Throuput and scalability. 
	+ ACID transactions: atomic, consistent, isolated, durable. 
	+ Journal storage. 

* Elastic Transcoder: LEGACY fully managed video transcoding service for Video on Demand (VOD) or streaming. 
* Media Convert: fully managed video transcoding service to convert videos from one format to another for VOD or streaming AND applying additional processing options. 
	+ Transcode only specific parts of a video: clips. 











____________________________________ SNS ____________________________________ 	// Handles real-time communication between my app's components. 

* Simple Notification Service: fully managed, HA, durable, secure publishers/subscriptions service to decouple microservices, distributed systems, and serverless apps. 
	+ SNS Topic: logical access point for communication. 
	+ Pub/Sub: pattern where sender of messages to an event bus that categorizes them into groups. The receivers of messages subscribe to these groups. Messages/events are automatically and immediately pushed to subs. 

* Sources (Publishers): AWS services: topics standard. 			// Publishers send messages to topics. 

* Destinations (Subscribers): 
	+ A2A (Application-to-App): Data firehose, Lambas, SQS, HTTP(S) endpoint, AWS Event Fork Pipeline. 
	+ A2P (App-to-Person): mobile apps, SMS (text messaging), email address, AWS Chatbot, PagerDuty. 

* Topics: 								// Example: newUser, when a new user registers in my app. 
	+ To group multiple subs together. 
	+ To deliver to multiple protocols at once. 
	+ Automatically format message according sub's protocol. 
	+ Can be encrypted via KMS. 
	+ Types: 
		' Standard. 					// May not show up in order and more than once. 
		' FIFO: guarantees message order. 			// Examples: bank txn, stock monitoring, flight tracking, price update apps. Strict ordering. 300 messages | 10MB /s. 

* Messages: 							// Units of communication. 
	+ Large messages: larger than 256KB, max 2GB. Must use Extended Client Lib. Saves the payload to S3 bucket. 
	+ Attributes: to provide structured metadata. 
	+ Batch Publishing: up to 10 at a time. 

* Subscriptions: 
	+ One proto & one topic. 
	+ Protos: HTTP(S), emaill (plain text), email-JSON, SQS, Lambda (triggers a function), SMS, Platform App endpoint. 

* Filter Policy: to filter a subset of messages only to be delivered. 
	+ Filter by message body: MessageBody. 

* Message Data Protection: safeguards data published to SNS topics by using policies to audit, mask, redact, block sensitive info. 
	+ Predefined %%% 

* Delivery Policy: how retries work when server-side errors. 
	+ Custom only for HTTP(S). 

* App as Subscriber: send push notification messages directly to apps on mobile devices. 

* BatchPublish action: publish up to 10 messages at a time, which helps reduce the SNS costs by a factor of 10. 

########################################################









____________________________________ SQS ____________________________________ 				// Problem: Microservice e-Commerce App: sequential processing, degraded perf, high cost. 

* Messaging system: to provide async communication via messages/events from sender to a receiver. 
* Queueing system: messaging system that generally deletes messages once they're consumed. 		// Solution: decouple each service by adding a queue between each. Benefits: Load Leveling, Async processing, Acalable archi. 
	+ Simple communication. 
	+ Not real-time. 
	+ Have to pull. 
	+ Not reactive. 

* Components: 
	+ Queue: buffer that stores messages. 
	+ Messages: units of comunication up to 256KB.  Attrs name:val. 	Visiblity timeout. 	Locking. 	Priority. 
	+ Producers: send messages. 
	+ Consumers: retrieve and process messages. 
	+ DLQ (Dead Letter Q): instead of keeping retrying a failed message. 

* Simple Queueing Service: fully managed queueing service. Use case: transaction emails to signup, reset password. 
	+ Publish message: SDK.  

* Types: 
	+ Standard: nearly unlimited number of transactions per second (tps). 		// Best-effort ordering. At-least-once delivery. 
	+ FIFO: 								// Strict ordering, delivered only once. Support: 300 messages/s, High troughput mode: 9,000 messages. 
		- Guarantees order of messages when being consumed. 
		- No duplicates. 
		- Consumer must specify: Message Group ID + Deduplication ID. 

* Size: 1 bye - 256 KiB. 

* Retention: 
	+ Default: 4 days. 
	+ Adjustable: 60s - 14d. 

* Encryption: SSE | KMS. 

* ABAC (Attribute-based access control): authorization process that defines permissions based on tags. 

// FIFO queues don't support timers on individual messages. 

* Temporary Queues: high-throughput, cost-effective, app-managed, temporary queues for request-response patterns. 

* Access Policy: grant other principals permission to the SQS Queue. 

########################################################


* Amazon MQ: managed message broker service for: 				// Managed service. App already using ActiveMQ or RabbitMQ migrating to the cloud but not having to re-write for SQS. 
	+ ActiveMQ. 
	+ RabbitMQ: supports advanced messaging protocols. 
	+ Like SQS for more complex delivery rules and performance guarantees.  
	+ AMQP (Advanced Message Queuing Protocol): open standard wire-level proto for middleware client/servers. 
	+ MQTT (MQ Telemetry Transport): ligh-weight pub/sub. Minimal netw bandwidth. For IoT or real-time messaging apps. For M2M communication. 
	+ STOMP (Simple Text Oriented Messaging Protocol): text-based wire-protocol for clients to communicate with almost any message broker. 


* Service Catalog: enables organizations to create and manage catalogs of products that are approved for use. 
	+ Alternative to granting direct access to AWS resources via Console to: 
		- Ensure consistent governance. 
		- Meet compliance requirements. 
		- Provide fine-grain access control. 
	+ Admin user: manages the catalog (me). 
		- Create portfolio: 					// Container for products, permissions, and constraints. A collection of products. 
			' Product: CloudFormation template. 
			' Permissions. 
			' Constraints: rules: Launch, Notification, Template, StackSet, TagUpdate. 
		- Service actions: SSM documents to perform tasks on the product. 
			' To let the end user perform maintenance. 
	+ End user: uses Catalog: user-friendly console to view and launch products. 
		- Provisioned products (CloudFormation stacks) are launched. 			// Product: CloudFormation template that defines the resources to be launched. 
			' Launch product "Minecraft Server" -> name it and choose version -> fill in params. 










____________________________________ CloudWatch _______________________________________

* Monitoring solution for my AWS resources. 
	+ Basic | Detailed. 

* Contributor Insights: Diagnostic tool. 
* Dashboards: graphs based on metrics. 		 * Alarms: trigger action when a metric passes a threshold. 		 * ServiceLens: tracing for serverless apps. 
^^^^^^^^^^^				^^^							^^^
* Metrics: turn logs into monitoreable variables. 													* Events (trigger based on conditions). 			* Container Insights: metrics for microservices. 
^^^^^^^^^^^									...->							^^^^ 						^^^^
* Logs: monitor, store, access. 
	+ I can export to S3. 
	+ Stream to Elasticsearch. 
	+ Stream CloudTrail Events to Logs. 
	+ Retention: indefinitely (default) | 1d - 10y. 
* Synthetics: test my apps. 

* Observability: measure and understand how a system works internally. 
	+ Metrics: a number measured over a period of time, like AVG CPU. 
	+ Logs: text file where each line is event data. 
	+ Traces: history of requests that travel through multiple services to pinpoint failure. 

* Log Group: a collection of log streams. 

* Log Stream: represents a sequence of events from an app or EC2 instance being monitored. 

* Log Event: represents a single event in a log file, within a Log Stream. 

* Log Insights: interactively search and analyze log data. 
	+ CloudWatch Logs Insights Query Syntax. 
	+ A single request can query up to 20 log groups. 
	+ Queries time out after 15m. 
	+ Query results available 7d. 
	+ Discovered Fields. 5 system fields: @message, @timestamp, @ingestionTime, @logStream, @log. 

* Metric: represents a time-ordered set of data points. 
	+ Variable monitored over time. 

* Availability of Data: 
	+ EC2: 5m. Detailed: 1m. 
	+ Other services: 1m (3m, 5m). 

* EC2 Metrics: 
	+ Host Level (defult): CPU, Netw, Disk, Status Checks (underlying Hypervisor & instance status). 
	+ Agent Level (need to install it): Memoty, Disk Space. 
		- To install CloudWatch Agent in an EC2 instance: SSM > Run a Command > AWS-ConfigureAWSPackage > Install, AmazonCloudWatchAgent, latest. Then attach CloudWatchAgentServerRole in IAM to instance. 

* Send logs from EC2 instance to CloudWatch Log Group using CloudWatch Agent: 
	+ Config the Agent: /etc/awslogs/awslogs.conf 
	+ Restart Agent service. 

* EventBridge: 						// Distributed App: components operate independently. They communicate with each other via events. Allows us to build event-driven loosely-coupled architectures. Event processing at scale. Event routing & filtering. Components: Event Bus (sources, rules, targets), Pipes ("filter, enrich, transform"), Scheduler. 	
	+ Serverless event bus service for app integration by streaming real-time data to my apps. 
	+ Event Bus: receives events from source and routes them to target based on rules. 
	+ Components: 
		- Bus: default, custom, SaaS. 
		- Producers: emit events. 
		- Events: JSON. 
			' version. 
			' id. 
			' detail-type. 			// Fields and values that appear in the detail field of the event. 
			' source. 
			' account. 
			' time. 
			' region. 
			' resources. 
			' detail. 
		- Rules: determines what events to capture and pass to targets (100 per bus). 
		- Targets: AWS services that consume events (5 per rule). 
	+ Scheduled Expressions: rules that trigger on a schedule (like serverless cron jobs). 
		- UTC time zone. 
		- Min precision: 1m. 
		- Cron | Rate expressions. 
	+ Configure input: 
		- Part of matched event. 
		- Constant (JSON text). 
		- Input Transformer. 
	+ Schema Registry: to create, discover, manage OpenAPI schemas. 
		- Schema: outline, diagram, or model to describe the structure of different types of data. 
		- See when structure of events changes. 
		- View schemas: VSCode -> install AWS Toolkit. 
	+ Event patterns: to filter what events should be passed to target. 
		- Prefix. 
		- Anythin-but. 
		- Numeric. 
		- IP addr. 
		- Exists. 
		- Empty. 

* Alarms: monitors a Metric based on a defined threshold. 
	+ States: OK, ALARM, INSUFFICIENT_DATA. 
	+ I define what action to trigger when it changes state. 			// Sending a notification. 
	+ Components: 
		- Type. 
		- Threshold condition. 
		- Metric. 
		- Data point. 
		- Period. 
		- Evaluation periods. 
		- Datapoints to ALARM. 
	+ Conditions: 
		- Static. 
		- Anomaly detection. 
	+ Composite: watches other alarms. 
		- To reduce alarm noise. 
		- Action: SNS topic. 

* Dashboard widgets: 
	+ Line. 
	+ Stacked Area. 
	+ Number. 

################################################################









____________________________________ Lambda _______________________________________ 

* Serverless Function as Service to run code (without provisioning or managing servers). 
* Pay only for the compute time consumed. 
* Glue services together. 
* Versioning supported: to publish new versions for testing without affecting the production version. 
	+ When referencing, unqualified ARN points to LATEST. 
	+ Alias: friendlier name. 
* Layers: up to 5. 
* Instruction Set: 									// Set of opcode that represents operations a CPU can perform. 
	+ arm64. 
	+ x86_64. 
* Runtimes: preconfigured env to run specific programming languages. 			// Ruby, Python, Java. 
	+ OS-Only: for when there's no preinstalled so I'd need to compile myself. 
		- Native AOT (ahead-of-time): Go, Rust, C++, .NET NAOT, Java GraalVM Native. 
		- 3rd-Party: Bref for PHP, Swift. 
		- Custom: build my own runtime. 
* Deployment packages: contains my code. 
	+ ZIP. Must upload to S3 if > 50MB. 
	+ Image: Docker. Must push image to ECR. 

* Max MEM: 10 GB. 
* Max ephemeral storage: 10 GB. 

################################################################


* Step Functions: coordinate multiple AWS services into serverless workflows. 		// Complex workflow orchestration, error handling, visual editor. 
	+ State Machine Types: 
		- Standard. 
		- Express: streaming data. 
	+ Amazon States Language (JSON). 
	+ Use cases: 
		- Batch -> SNS notify suc/fail. 
		- Fargate Task ... 
		- Transfer Data Records: DynamoDB read message -> SQS. 
		- Microservice Orchestration. 
		- With human approval. 
		- Invoke business process in response to an event. 
		- Notify admin that secret has been publicly exposed via repo. 
		- Sync data between S3 buckets. 
		- Data processing pipeline for streaming data. 
		- Split and transcode video using massive parallelization. 
	+ States: 
		- Pass: no work. 						// Useful for constructing and debugging state machines. 
		- Task: single unit of work. AWS Lambda, API actions, Activity (external worker continously polls). 
		- Choice: branching logic. 
		- Wait. 
		- Succeed. 
		- Fail. 
		- Parallel. 
		- Map: iterate over array. 
	+ I/O: receive JSON event data as input and pass JSON as output. 



* Compute Optimizer: analyzes my compute resources utilization metrics (CloudWatch) over at least 14 days and recommends config changes to save money. 


* Elastic Beanstalk: 
	+ PaaS: Platform to develop, run, manage apps infrastructure-less. 
	+ Not recommended for PRODUCTION apps. 
	+ Choose platform, upload code. 
	+ Supported langs: 
		- Ruby -> Rails. 
		- Python -> Django. 
		- PHP -> Laravel. 
		- Tomcat -> Spring. 
		- Node.js -> Express. 
	+ Env: 
		- Web: ASG, ELB. 
			' Load-Balancer env. 
			' Single-Instance env. 
		- Worker: ASG, SQS. 




* Kinesis: fully managed solution for collecting, processing, analyzing streaming data. 	//"Real-time". 
	+ Examples: stock prices, game data, social netw, geospatial, click stream. 
	+ Stream types: 
		- Data: custom producers & consumers. 
			' Capacity modes: 
				` On-demand: dynamically scale up/down. Pricier. 
				` Provisioned: if I know what the throughput requirements are. 
		- Firehose: serverless, simple. 					// ETL via Lambda -> storage location. Up to 60s. 
			' Before data is sent to a destination it can be transformed with AWS Lambda. 
			' Dynamic Partitioning: to continuously partition streaming data by using keys and then deliver the data grouped by these keys into S3 prefixes. 
			' Destinations: S3, Redshift, OpenSearch, Splunk, 3rdPs. 
		- Fink: run queries and create reports. Custom SQL. 		// Query data FLOWING through real-time stream to create reports on emerging data. 
		- Video. 							// + Audio, Sensor data. 
	+ Producers: 
		- Agent: monitors files. 
		- SDK: PutRecord. 
		- Direct integration: Aurora, CloudFront, DynamoDB, etc. 
		- KPL (Producer Lib): JAVA only, scales. 
	+ Consumers: 
		- 3rdP: Fink, Kafka Connect, Adobe Experience, Oracle GoldenGate. 
		- Firehose. 
		- SDK: GetRecords. 
		- KCL (Client Lib): to write my own custom consumers. 		// To simplify consuming data from Amazon Kinesis streams. 
	+ Shards: 								// Are like VMs. Scalability: add shards. 
		- A Kinesis Data Stream is a set of shards. 
		- Read: up to 5 transactions per second, max rate of 2MB/s. 
		- Writes: up to 1,000 records/s, max rate 1 MB/s. 
		- Sequence of data records, each has a sequence number. 
	+ Partition keys: 
		- To group data by shard within a stream. 
		- Unicode, max len 256 chars. 
		- An app that puts data into a stream must specify a partition key. 
	+ Data Retention: 24h default, up to a year ($). 
	+ Enhanced Fan Out (EFO): up to 20 consumers, throughput up to 2MB/s/shard. 		// Consumers must be configured with KCL | Streams API. 
	+ Data Durability/Availability: data records are replicated across multiple AZs. 



* ElastiCache: 
	+ Caching: temporary storage optimized for fast retrieval (data is not durable). 
	+ In-Memory Data Store: low durability, risk of data loss, access very fast. 
	+ Fully managed in-mem datastore for: 
		- Memcached: preferred for HTML fragments. Simple key:value store. 
			' OSS key:value store. 
			' Telnet to interact. 
			' Set, Get, Delete, Incr, Decr, Add, Replace key, Append, Prepend, Stats. 
		- Redis: OSS very fast DB. Key:value: string, set, sorted set, list, hash, bitmap, bitfield, hyperLog, geospatial index, stream. 
			' Strings: binary safe (e.g. JPEG image, serialized Ruby object), max len 512MB. 
			' Lists: ordered. 
			' Set: unordered unique. 
			' Hash: mapping between string fields to string values to represent an object. 
			' Sorted sets: based on associated score. 
	+ Only accessible by resources in same VPC to ensure low-latency. 
	+ Can be replicated cross-region via ElastiCache Global Datastores. 
	+ Deploy: 
		- Standard. Can be deployed on-prem via Outposts. 
		- Serverless. 

* MemoryDB: Redis-compatible in-mem DB, suitable as primary DB. 			// Provides additional persistence guarantees. 









____________________________________ CloudTrail _______________________________________

* Logs API calls between services. 					// Who to blame. 
* Event History: 90 days default. 
* Trail: collect logs beyond 90 days. 
* Can deliver events to CloudWatch: enables SNS notifications on specific activities. 
	+ Management events. 
	+ Data events: S3, Lambda. 
* Enables governance, compliance, operational & risk auditing. 

################################################################




* RedShift: managed, petabyte-scale Data Warehouse. 		// Data Warehouse: consolidate data: data integration. Provide unified view of data for informed business decitions. Optimized for analytics. Historical data. Data transformation: ETL. Structured Data at aggregate level. 
	+ For BI. 
	+ Uses OLAP (Online Analytics Processing System). 
	+ Columnar storage. 
	+ Leader Node + Compute nodes. 
	+ Redshift Managed Storage. 
	+ MPP: Massively Parallel Processing. 
	+ Data compression. 
	+ Automated and continous backups. 
	+ HA. 
	+ Concurrent users. 
	+ Use cases: financial and demand forecasts, BI. 

* RedShift Serverless: 
	+ RPUs: RedShift Processing Units. I Pay for workloads run in RPU-hours on a per-second basis. 
	+ Base Capacity. 1 RPU = 16 GB RAM. Adjust: 8 - 512 RPU. 8-12 RPU: 128 TB data. Min: 32 RPU. 





* Athena: interactive query service to analyze data directly from S3. 				// Dashboard + Search Query Engine. 
	+ Athena SQL: Tinro SQL. 
		- Workgroup: saved queries. 
		- Data src: catalogs. 
		- DB: schema. 
		- Table: rows or cols. 
		- Dataset. 
		- DDL (Data Definition Lang): subset of SQL to define schema: CREATE, ALTER, DROP. 
		- DML (Data Manipulation Lang): manipulate datasets: INSERT, UPDATE, DELETE. 
		- DQL (Query): SELECT. 
		- Data Types: Boolean, Tinyint, Smallint, Integer, Bigint, Float, Double, Decimal, Char(n), Varchar(n), String, Ipaddress, Binary, Date, Timestamp, Array<data type>, Map<primitive_type: data_type>, Struct. 
		- Table: AWS Glue Data Catalog Table. 
		- SerDe: serialization/deserialization libs for parsing data from data formats like CSV, JSON, Parquet, ORC, Avro. 
	+ Spark: Jupyter. 
	+ Serverless. 



* QuickSight: visualization dashboard. Show data nicely. 
	+ SPICE (Super-fast Parallel, In-Memory Calculation) Engine. 







____________________________________ Machine Learning _______________________________________

* CodeGuru: code analysis service. Code reviews. Security, Profiler, Reviewer. 
* Comprehend: NLP (Natural Lang Processor): finds relationships between text for insights. 
	+ Entities, lang, PII, sentiment. 
* Forecast: time-series forecasting service. Forecasts business outcomes like product demand, financial perf. 
	+ Out: visual graph. 
* Fraud Detector: fully managed. Online Fraud Insights: detect fraud with minimal historical data. 
* Kendra: search engine service. 
	+ Semantic & contextual understanding. 
	+ Index (documents (PDF)), Data Source (Template Schemas), Document Addition API. 
	+ Edition: Developer | Enterprise. 
* Lex: conversation interface service. Voice and text chatbots. 
	+ Integrated with Lambda. 
	+ Components: bot, version, alias, languages, intent, sample utterance, slot, slot type. 
	+ Intent: action that user wants to perform. 
* Personalize: real-time recommendations. 
	+ Workflow: create data set group, upload data set to S3, solutions and recipes, event tracking, filters, campaign. 
	+ Required data sets: User-Item interaction, User, Item. 
* Polly: text-to-speech. 
	+ Engine types: standard, long form, neural. 
* Rekognition: image and video recognition service. Detect and label objects, people. 
* Textract: OCR (extract text from scanned documents). 
	+ Receipts, IDs. 
* Translate: neural machine learning text translation service (deep learning). 
	+ Real-time | async batch. 

####################################################################



* Data Exchange: catalog of 3rdP datasets. 
	+ Free, upfront commitment, usage based. 



// ETL data from different sources, deliver into a data repo. 
// Glue job: Datasource -> Crawler -> Data Catalog. 
// Serverless. 
* Glue (ETL): serverless data integration service for analytics users to discover, prepare, move, integrate data from multiple sources. 
	+ Studio: visually build ETL (Extract Transform Load) pipelines. Nodes. Sources, Transforms, Targets. Version control. Python script. 
	+ Jobs: charged DPU (Data Processing Units). 
		- Python Shell Engine. 
		- Ray. 
		- Spark. 
	+ Data Catalog: fully managed Hive metastore-compatible to store, annotate, share metadata. Serverless. 
		- Glue DB: tables. 
		- Table: metadata definition. 
		- Crawler: tool to discover schema formats and generate Glue Data Tables. 

* Glue Databrew: visual interface. Completely visual data prep tool to clean & normalize data. 
	+ No code. Only GUI. Serverless. 
	+ Create Project > Select Datasets > Select Recipes > Run Jobs. 
	+ Auto Data Profiling. 
	+ Auto Scales. 


* Lake Formation: data lake to govern, secure, globally share data. 		// Aggregation of meaningful data sets in a company. 
	+ Commonly stored as: object (blobs), files. 			// <- storage medium. 
	+ Data Lake: centralized data repo for unstructured, semi-structured data. Storage: generally object (blobs) | files. 
	+ Collect -> Transform -> Publish. 
	+ Granular access: Athena, Quicksight, Redshift Spectrum, EMR, and Glue. 
	+ Ingestion > Storage (S3) can be stored in parquet | ORC (optimized for analytics) > Processing. 


* Amazon API GW: solution for creating secure APIs at any scale. 				// Config CORS: x-amazon-apigateway-cors 
	+ API GW: sits between single-entry point and multiple backends. 
	+ OpenAPI Specification (OAS): standard, lang-agnostic interface to RESTful APIs to discover capabilities of the service. 
	+ Swagger: tools for implementing it. 
	+ JSON | YAML. 
	+ Types: 
		- Rest: 								// Methods: allow customizing requests/responses for endpoints. 
			' Stages (PROD). 
			' API: Resources: endpoints (/hello): Methods (GET, PUT). 
			' Integration. 
		- HTTP: low latency, lower cost, public API only. Endpoint: regional. Security: TLS. Authorization: IAM, Cognito, Custom with Lambda. API mgmt: API keys, per-client rate lim, usage throttling. Development: automatic deployment, user-controlled deploys, CORS config, Request Param Transform. Monitoring: CloudWatch Metric & Logs. Integrations: Public HTTP endpoints, AWS Services, Lambda functions, Private NLB, ALB, Cloud Map. 
			' Stages: $default (autodeployed). 
			' API: Routes (PUT /hello): 
			' Integration: EventBridge, SQS, AppConfig, Kinesis Data Streams, Step Functions. 
		- WebSockets: persistent connection. 					// Use cases: real-time: chat, dashboards. 
	+ Extensions: 
		- -policy. 
		- -cors. 






* DBA: 
	+ Routine DB ops. 
	+ HA + Fault Tolerance. 
	+ Scalability. 
	+ Backup and Restore. 
	+ Monitoring + Performance. 
	+ Security. 

____________________________________ RDS _______________________________________ 

* Instance types: 
	+ General Purpose. 
	+ Memory Oprtimized. 

* Storage: 
	+ General Purpose SSD: medium size DB, dev/testing env, 3 IOPS/GB -> 3,000. 
	+ Provisioned IOPS SSD: IO intensive, low latency, consistent throughput, prod env, min 100GB, man 16TB. 
	+ Magnetic: legacy, HDD: slower, being phased-out. 

* Config: 
	+ Param groups. 
	+ Option groups. 
	+ Subnet groups. 
	+ Security groups. 
	+ Snapshots. 
	+ Param store. 
	+ Perf insights. 
	+ Enhanced Monitoring. 
	+ Audit + Log data. 
	+ SSL + enc. 

* Relational DB Service: managed for multiple DBs. 
* Encryption: at-rest for all engines. In-transit by default via DB DNS endpoint. 
* Backup: has to be "available" state. 
	+ Automated: enabled by default. 0 days: turned off. 
	+ Manual Snapshots: $. 
* Restore: creates a new RDS instance. 
	+ PITR: Point-In-Time Recovery. 
* Subnet Groups: collection of subnets (usually private). 
	+ All subnets must be public for the instance to be publicly accessible. 
	+ At least 2 AZs. 
* Multi-AZ: one or 2 standby RDS clusters or instances for fail over. 	// Async replication. 
	+ Instance: RDS Instances. 
	+ Cluster: Aurora Custers. 
* Read Replicas: to run multiple read-only copies of DB. 		// Read from multiple (active-active). 
	+ To improve read contention. 
	+ Auto backups must be enabled. 
	+ Async replication. 
	+ Multi-AZ (sync replication), cross-region, of other replicas. 	// Stand-by instance for fail over. 
* DB Instance: isolated DB env. 
	+ One or multiple user-created DBs. 
	+ Has DB identifier. 
	+ db.*: general purpose, mem-optimized, burstable-perf, optimized reads. 
	+ Storage: EBS. Max: 64TB. 
* Perf insights: default 1 week. 
* Custom: automates DB admin, directly manage aspects of RDS. 
	+ MS SQL S, Oracle. 
* Proxy: creates a connection pooler so short-lived Lambda functions do not exhaust connections. 		// Fully managed, HA. 
* Optimized R/W: maximize perf, efficiency, throughput. 
	+ NVMe-based SSD block storage instead of EBS for temporary tables: sorts, hash aggregations, high-load joins, CTEs (Common Table Expressions). 
* IAM Authentication: authn with token to RDS instance's DB. 
	+ MySQL, MariaDB, Postgres. 
	+ Create a policy, attach to user|role. 
* Kerberos: netw authn proto. 
* Secrets Manager can manage RDS instance's master user password. ($) 
	+ Default rotation period: 7d. 
* Master User Account: initial DB account with FULL ADMIN privileges. Set at time of creation. 
* Activity Streams: control admin access to data streams. 
	+ Auto: Kinesis. 
* Param Groups: container for engine config values. 
* Establish Public Connection: DB IDE, CloudShell, DB client. Connection url string: contains all params. 
* Private connection: Cloud9 in same VPC, through Bastion, EC2 instance SSH SSM, Client VPN, on-prem: Direct Connect. 
* Security Groups: to establish connection open the port. 
* Blue/Green Deployment: copies a prod DB env to a separate sync staging env. 		// Production (blue) / Staging (testing, green): logical replication. Move clients over to green and swap colors. Same AWS account. 
* Extended Support: $$$ run DB past end of standard support up to 3 years. 

* For staging/dev envs: SINGLE RDS DB. If AZ goes down, data is lost. 


* Aurora: fully managed RDB cluster. 
	+ 5x better perf than traditional MySQL. 
	+ 3x better perf than traditional Postgres. 
	+ Features: 
		- Backup/Failover: auto. 
		- Storage: self-healing. 
		- Min 3 AZs, 2 copies of data at all times. 
		- Storage: 10GB. Max: 64TB. 
		- Up to 32 vCPUs. 
	+ Default config: Serverless Provisioned. 
	+ Instances: Writer, Reader(s) (up to 15). 
	+ V2: fully-manages autoscaling. 
		- At least 0.5 ACUs. 
		- ACU (Aurora Capacity Unit): max 128. 
	+ Serverless (scales R/W ops independently) VS Provisioned. 
	+ Global: spanning multiple regions for low-latency. 
		- Primary Cluster: writer. 
		- Up to 5 secondary clusters. 
	+ RDS Data API: HTTP requests to securely query. 
		- $ aws rds enable-http-endpoint --resource-arn <CUSTER_ARN> 
	+ Babelfish: extends Aurora Postgres cluster with the ability to accept DB connections from MS SQL S. 
		+ Port: 1433. 

#########################################################

* DocumentDB: NoSQL doc DB MongoDB compatible. 
	+ Document Store: NoSQL DB that stores documents: XML | JSON. Sub-class of key:value stores. 
		- Collection -> Documents -> Fields. Indexes. Embedding & Linking. 
	+ MongoDB: OSS which stores JSON-like docs. 
		- Primary data structure: BSON (Binary JSON). 
		- Interactive shell: mongosh. 
		- Port: 27017. 
		- FS: GridFS. 
	+ Cluster types: 
		- Instance based. 
		- Elastic. 
	+ Not supported: writable retries. 


* DynamoDB: NoSQL key/val and document DB for internet-scale apps. 
	+ NoSQL: not relational, no SQL for query. 
	+ Key/Value Store: key references a value. 
	+ Fully Managed & serverless. 
	+ Multi-region with Global Tables. 
	+ Multi-master. 
	+ Stored in SSD, 3 AZs. 
	+ Tables, Items, Attributes, Values. 
	+ Read Consistency: when data is updated, it has to be written to all copies. Can be inconsistent when reading a copy not yet updated. 
		- Eventually Consistent Reads: fast, no guarantee, generally consistent within a second. 
		- Strongly Consistent Reads: will not return a result until all copies are consistent (guarantee, higher latency), within a second. 
	+ Partitions: 
		- Allocation of storage for a table SSD auto replicated across AZs (same region). 		// Slicing a table in smaller chunks. 
		- Auto. 
		- Every 10GB | WCU/RCU exceeded. 
		- Item: collection of data with uniq key in a table. 
	+ Primary Keys: must be defined. Cannot change. 
		- When using both Partition Key and Sort key: Composite Primary Key. 
		- Simple: internal hash function decides which partition to write data to. 
		- Composite: combination has to be unique. 
	+ Query: find times based on primary key. 
	+ Scan: through all items and return one or more through filters. 	// Avoid when possible. 
		- Param to speed up: segments. 
	+ To transfer data records: first seed the table. 
	+ Scales to 0. 
	+ Secondary Indexes. 
	+ On-Demand Backup and Restore. 
	+ Table Classes: 
		- Standard. 
		- Standard-Infrequent Access. 
		- On-Demand. 

* DynamoDB Accelerator (DAX): caching service. 
	+ Read 10x perf even @ million of requests per second. 
	+ HA: Primary Node + Read Replicas. 
	+ Extreme perf. 
	+ Scale on demand up to 10 node cluster. 
	+ Fully managed. 


* KeySpaces: fully managed Apache Cassandra DB. 		// Scalable, HA, Serverless. 
	+ NoSQL key:val columnar store. 
	+ Cluster: nodes. 
	+ Node: holds 2-4TB. R/W. 
	+ Ring: nodes connected to each other. 
	+ Keyspace: namespace specifies data replication. 
	+ Table: cols + rows with pk. 
	+ Throughput capacity modes: 
		- On-Demand: pay as I go, dynamic capacity. 
		- Provisioned: optimize price, planned capacity. Once per day capacity change. 
	+ Multi-Region Replication: active-active. 
	+ Use cases: low latency. 

* Neptune: graph DB. HA. Gremlin, SPARQL, OpenCypher. 			// Complex relationships. Fully managed, serverless. Global. 
	+ Graph DB: vertices + edges. 
	+ ML: DGL (Deep Graph Lib). 
	+ Types: Provisioned | Serverless. 
	+ Multi AZ. 
	+ Storage: IO optimized | standard. 
	+ Bulk Loader: import data. 
	+ Gremlin: graph traversal lang. 
	+ OpenCypher: graph query lang. 		// Easier than Gremlin. 
	+ SparQL: Resource Description Framework to query key/val data. 










* ECR (Elastic Container Registry): fully managed Docker to store, manage, deploy images. 
	+ OCI: Open Container Initiative. 
	+ Registry: contains repos. Public | Private. 
	+ Repo: contains images. 
	+ Image: can have multiple tags. 
	+ Tag: points to specific image version. 
	+ To prevent an image (with specific version) from being overwritten: set its tag to IMMUTABLE. 



____________________________________ ECS _______________________________________

* ECS-EC2 (Elastic Container Service for EC2): container orchestration to run containers accross multiple EC2s managed in a cluster. 
	+ Cluster: EC2s. 
	+ Task Definition: JSON for up to 10 containers. 
	+ Task: launches containers that exit once workload completes. 
	+ Service: tasks remain running like WebApp. 
	+ Container Agent: monitors, starts, stops tasks. 
	+ ECS Controller (Scheduler): schedules deployment and placement of containers, replaces unhealthy containers. 

* ECS-Fargate: serverless orchestration container service. 
	+ I don't need to provision, configure, scale EC2 clusters. 
	+ Charged at least 1 minute, then per second. Duration + consumption. 
	+ Networking mode: awslogs, ENI in VPC per Task Group. 
	+ ELB: IP addr. 
	+ I define mem and vCPU in Task Definition. 
	+ Then add containers and allocate resources required of each. 
	+ To run Task, select VPC and subnet. 
	+ Apply SG and roles to Tasks & Services. 

* Execution Role: to prepare or manage container: 
	+ Permissions: 
		- Secrets Manager | SSM Param Store. 
		- Download private image from ECR. 
		- CloudWatch Logs full access. 

* Task Role: used by the running compute of the container. 
	+ Permissions: 
		- SSM Messages | ECS Exec. 
		- CloudWatch Logs full access. 
		- XRay Daemon Write access. 

* Capacity Providers: manage the scaling of infra for tasks in my clusters. 
	+ Each cluster will have 1 or more + optional Capacity Provider Strategy. 
	+ Fargate predefined: FARGATE | SPOT. 

* Task lifecycle: 
	+ Running. 
	+ Stopped. 
	+ Deleted. 
	+ Activating/Deactivating. 
	+ Pending/Stopping. 
	+ Provisioning/Deprov. 

* Task Definition JSON: 
	+ Family: task definition group. 	//Versioning. 
	+ Exec Role. 
	+ Task Role. 
	+ Netw Mode: Host, Bridge, AWSVPC, None. 
	+ CPU + Mem. 
	+ Required Capacity. 
	+ Container Definition: 
		- Name. 
		- Image. 
		- Essential: main. 
		- Health Check. 
		- Port Mappings: 
			' Bridge Mode: cont <> host. 
			' Host Mode: cont = host. 
			' AWSVPC Mode: cont has own netw if with public IP. Same as host. 
		- Log Config. 
		- Env. 
		- Secrets. 
		- CPU/Mem. 

* Exec: interact directly with the container as root. 
* Log Config: I can set a log driver when configuring my containers. 
	+ Default: awslogs -> CloudWatch Logs. 
* ECS Service Connect: service mesh S2S communication. 
	+ Creates a CloudMap Namespace. 
* Bottlerocket: Linux-based OSS OS for containers. 
* ECS Anywhere: register external VMs residing on-prem netw to my ECS cluster. 

##########################################################





____________________________________ EKS _______________________________________

* Elastic K8 Service: managed Control Plane (no need to install, operate, maintain). 
	+ KubeCTL: connect and manage cluster. 
	+ Inbound connection: ALB ingress controller. 
	+ Add-Ons: VPC CNI plugin for K8, CoreDNS, Kube-proxy, Pod ID Agent. 
	+ EKS Connector: bring your own K8 cluster to EKS. 
	+ EKS CTL: to deploy cluster. 

* EKS Distro (EKS-D): K8 distribution based on and used by EKS to create reliable and secure K8 clusters. 

* EKS Anywhere (EKS-A): deployment option for EKS to create and operate K8 clusters on-prem with my own VMs or bare metal. 
	+ Deploys the EKS-D. 
	+ To manage my clusters from AWS Management Console. 
	+ Admin Machine. 
* Traces & Spans: 
	+ Trace: data/execution path through the system: Directed Acyclic Graph (DAG) of spans. 
	+ Span: represents a logical unit of work in Jaeger: operation name, start time, duration. 
* Open Telemetry (OTel): collection of OSS tools, APIs, SDKs to instrument, generate, collect, export telemetry data. 
	+ Wire protocol. 
	+ ADOT (AWS Distro 4 OpenTelemetry): secure, production-ready distro of OTel. 
	+ Instrumentation: embedding a monitoring lib in my app. 
* Prometheus: OSS systems monitoring and alerting toolkit. 
	+ Timeseries DB (TSDB). 
	+ AMP (Amazon Managed Service 4 Prometheus): fully managed monitoring for container infra and apps metrics. 
		- To securely monitor container envs at scale. 
		- Use AMSG (Amazon Managed Service 4 Graphana) to visualize data. 
		- PromQL. 
* Graphana: OSS analytics and interactive visualization. 				// Beautiful dashboards. 
	+ Types of data: operational metrics, logs, traces. 
	+ Amazon Managed Grafana: fully managed, interactive data visualization, unified observability, SSO. 

##########################################################







* KMS (Key Management Service): create and manage (control, rotate) enc keys. 
	+ Multi-tenant HSM (HW Security Module). 
	+ Some services that integrates with: RDS, CodeCommit, S3, CodeDeploy, Glacier, SNS, SQS, DynamoDB, EC2, X-Ray, ElastiCache, CodeBuild. 
	+ CloudHSM: single-tenant (dedicated). 
	+ Customer Master Key (CMK): stored in secure HW. Used to encrypt all other keys (Envelope Encryption). Master Key -encrypts-> Data Key -encrypts-> Data. Logical representation of a master key. Metadata: key ID, creation date, descr, key state. Supports symmetric and asymmetric. 
	+ CLI: $ kms: create-key, encrypt, decrypt, re-encrypt, enable-key-rotation. 


* Audit Manager: continually audit AWS usage for risk/compliance assessment. 
	+ Services integrated: Config, Security Hub. 
	+ Framework Lib: browse compliance standards, like SOC2, HIPAA. 
	+ Control Lib. 
	+ Create assessments to review evidence and generate report. 
	+ Collect evidence. 

* ACM (Amazon Certificate Manager): provision, manage, deploy public/private SSL/TLS certs. 
	+ Domain: example.com, *.example.com. 
	+ ELB, CloudFront, APIGW. 
	+ Terminating SSL: 
		- @ LB. 
		- End-To-End. 
	+ Cannot be directly used with: 
		- EC2. 
		- S3. 
		- Lambda. 
	+ Region specific. 


* Cognito: customer id and access management (CIAM) system. 
	+ Provides authentication, authorization, user management for my web/mobile apps. 
	+ AuthN to AWS Services. 
	+ User Pools: directory with authN to IdP (Identity Providers). 
	+ Identity Pools: provide temp creds for users to access AWS Services. 
	+ Sync: syncs user data and preferences accross devices. 


* Amazon Detective: analyze, investigate, identify root cause of security findings or suspicious activities. 
	+ Metrics for EC2, principles: SUC & Fail rates, Bytes IN/OUT. 


* Directory Service: maps the names of netw resources to their netw addresses. 
	+ Shared infra info for locating, managing, administering, organizing resources: 
		- Volumes, folders, files, printers, users, groups, devices, etc. 
	+ Examples: DNS (dir service for The Internet), MS Active Dir. 
	+ Active Dir: Windows 2000. Azure AD. Forrest -> Domain -> Tree -> Child Domain <- Organization Units. 
		- To manage multiple on-prem infra components/systems using a single id per user. 
	+ LDAP (Lightweight Directory Access Proto): open, vendor-neutral, indistry standard app proto for accessing and maintaining distributed dir info services over IP. 
		- Provide central place to store username/passwords. 
		- Enabled same-sign on. 
	+ AWS Dir Service: multiple ways to use MS Active Dir. 
		- Simple AD (Samba 4). 
		- AD Connector (proxy to on-prem AD). 
		- Managed MS AD. 



* Firewall Manager: centrally config and manage FW rules accross accounts and apps. 
	+ Required: Organizations, Config. 
	+ WAF, Shield, SGs, Netw Access Controls, Netw FW, Route53 Resolver DNS FW, 3rdP. 


* Inspector: runs security benchmark against EC2 instances. 
	+ Netw & Host assessments. 
	+ Hardening: eliminating security risks. 
	+ CIS Benchmark: 699 checks. 

* Macie: issues with S3 buckets with Personal Identifiable Info (PII). 


* Security Hub: Cloud Security Posture Management (CSPM) to generate a security score to determine security posture. 
	+ Enable standards: collection of security controls. 
	+ Findings. 


* Secrets Manager: protect secrets needed to access apps and services. 
	+ Rotate, manage, retrieve DB creds, API keys. 
	+ RDS, Redshift, DocumentDB, Other DBs, Key/Value. 
	+ Auto rotation: for DB creds. 
	+ CLI: $ secretsmanager: describe-secret, get-secret-value. 
	+ Max auto key rotation: 365d. 
	+ $. 


* AI Dev Tools: 
	+ Amazon Q: AI chatbot, multiple LLMs via Bedrock. 
		- Business, Developer, QuickSight, for Connect, Supply Chain. 
	+ CodeWhisperer: real-time AI coding companion. 


* MSK (Managed Streaming Apache Kafka): fully managed. 
	+ Build & run apps that use Kafka to process streaming data. 
	+ Nodes: broker, ZooKeeper. 
	+ Clusters: provisioned, serverless. 
	+ To connect to cluster: bootstrap broker endpoint. 
	+ Connect: bring data in from other sources. 
	+ Kafka: OSS streaming platform, high-perf data pipelines, streaming analytics, data integration, mission-critical apps. JAVA. 
		- Producers, Consumers, Topics. 
		- CLI: bash scripts. 
	+ Zookeper: OSS server for highly reliable distributed coordination of cloud apps. 
		- Common services expose: naming, config mgmt, sync, group. 
	+ Services integrate: S3, EventBridge. 
	+ Amazon manages: Broker & ZooKeeper nodes. 
	+ I manage: 
		- Serverless: nothing. I just specify capacity. 
		- Managed: Producers, Consumers, Cluser Operation. 
	+ Reliability & HA: automated backups, multi-zone replication. 
	+ Monitoring & Alerts: CloudTrail, CloudWatch. 


* Shield: managed DDoS protection service that safeguards apps. 
	+ Auto when routing traffic through Route53 or CloudFront. 
	+ OSI Layers: 3, 4, 7. 

* WAF (Web App FW): protect web app from common web exploits. 
	+ Write rules, use ruleset from security partner, protect from attacks covered in OWASP Top 10. 
	+ DDoS: disrupt traffic by flooding a website with fake traffic. 
	+ WebACL: rules. Conditions and actions. 

* CloudHSM: single-tenant HW Security Module. 
	+ HW designed to store enc keys in mem, never in disk. 
	+ FIPS 140-2: 
		- Multi-tenant: level 2. 
		- Single-tenant: level 3. 
	+ Automates HW provisioning, SW patching, HA and backups. 

* Guard Duty: threat detection service that continously monitors for malicious, suspicious activity, unathorized behavior. ML logs: CloudTrail, VPC Flow, DNS. 
	+ IDS/IPS: intrusion protection. 
	+ $. 

* Service Health Dashboard: shows general status of AWS services. 
	+ Public Events: AWS announces an issue with a service. 
	+ Private Event: an issue with an Account. 
* Personal Health Dashboard: provides alerts and guidance for AWS events for my specific Account. 

* Artifact: self-serve portal for on-demand access to AWS compliance reports. 
	+ See if AWS ITSELF is compliant. 


* Storage GW: connects on-prem SW apps with cloud-based storage. 			// Hybrid Cloud storage service. Acts as a bridge between on-prem & cloud-based storage. Alows to seamlessly integrate on-prem apps with cloud storage resources. 
	+ Purposes: 
		- Extension for on-prem storage needs. 
		- Assists migrations into the Cloud. 
		- Backups. 
		- Disaster Recovery. 
	+ Either VM | physical device. Exists on on-prem env. 
	+ File GW: within on-prem env. SMB | NFS. 		// Data stored in S3. File key = /path/to/file.ext. 
		- File GW to S3. 
		- File GW to FSx: WFS (Windows File Server). 
	+ Volume GW: mount S3 as local drive. Proto: iSCSI. 
		- Cached: frequent. 				// Data is stored on S3. Local cache on-prem for frequent files. Extends storage. 
		- Stored: primary data + backup. 		// Backup only. Volumes consume capacity on-prem. Data is stored locally and replicated async to AWS. Copies data over to S3 as EBS snapshots. So doesn't increase datacenter storage capacity. 
	+ Tape GW: VLT (Virtual Lib Tapes) long-term backup. Store: Virtual Tape Cartridges. 	// Tape drive: R/W. 
		- Emulates a Tape Drive. 
		- Data stored in S3: 
			' VTL (Virtual Tape Library). 
			' VTS (Tape Shelf Glacier). 
		- Virtual Tape: 100GB - 5TB. 



* HA (High Availability): ability for a system to remain available. 
	+ AZ becomes unavailable: 				Multi-AZ with ELB. 
	+ Region becomes unavailable (very unlikely): 		Instances in another region and Route53. 
	+ Webapp becomes unresponsive due too much traffic: 	Auto Scaling Groups to meet demand. 
	+ Instance becomes unavailable (failure): 		Auto Scaling Groups to ensure a min amount of instances running + ELB. 
	+ Webapp becomes unresponsive due to geo distance: 	CloudFront to cache static content. 


* Scale: when utilization increases and we're reaching capacity. 
	+ Up (Vertical): increase SIZE of instance(s). 
	+ Out (Horizontal): add more instances (same type). 
	+ Generally we want to scale out and then up to balance complexity VS availability. 












____________________________________ CloudFormation (CFN) ____________________________________ 

* built-in IaC tool in AWS. 
* IaC: blueprint to automate creation, updating, destroying cloud infra. Share, version, inventory cloud infra. 
* Stacks are deployed infra from a CFN template. 
* JSON | YAML. 
* At least one resource in template. 
* Stack states: REVIEW_IN_PROGRESS, CREATE_COMPLETE, DELETE_FAILED, UPDATE_*. 
* A Stack can be updated: 							// Update: no int, some int; replacement. 
	+ Direct. 
	+ Change sets. 
	+ Can cause interruption & replacement. 
* Stack Policies: to prevent data loss, service interruption. 
* Stacks can be nested. 
* CFN attempts a rollback in case of error. Turned on by default. 	$ --ignore-rollback 
* Drift: when actual config differs from CFN. 
	+ CFN can detect drift. 
* ChangeSet: indicates what will be changed before executing a deployment of a stack. 	$ --no-execute-changeset 
* Pseudo Params: predefined vars in CFN. !Ref AWS:: 
	+ Build ARN: ! Sub "arn:aws:s3:::${AWS::AccountId}-${AWS::Region}-mybucket"
* Resource Attrs: 
	+ Creation Policy: cfn-signal. 
	+ Deletion Policy: Delete, Retain, Snapshot. 
	+ UpdatePolicy: how to handle. 
	+ UpdateReplacePolicy. 
	+ DependsOn. 
	+ MetaData: cfn-get-metadata. 
* Intrinsic Functions: assign values to properties that are nor available until runtime. 
	+ Ref. 			// !Ref 
	+ Fn::GetAtt. 
	+ Fn::And, Equals, If, Not, Or. 
	+ Fn::Base64. 
	+ Fn::Cidr. 
	+ Fn::Transform. 
	+ Fn::GetAZs. 
	+ Fn::ImportValue. 
	+ Join, Select, Split, Sub, FindInMap. 
	+ AWS::LanguageExtensions: 
		- ForEach. 
		- ToJsonString. 
* Wait Conditions. 
* IaC Generator: scan existing resources in my account and generate CFN template. 
* Helper Scripts: python to install SW, start services on EC2 instance. 
	+ cfn-init, cfn-signal, cfn-get-metadata, cfn-hup. 
* Custom Resources: external infra. 
* CFN Registry: manage extensions (public|private): resources, modules, hooks. 
* StackPolicy: JSON document defines update actions that can be performed on designated resources. 
* Deletion Policy: Delete, Retain, Snapshot. 

#####################################################################




* OpsWorks: config mgmt service of Chef and Puppet. 

* DNS: 
	+ Internet Assigned Numbers Authority (IANA): controls top-level domain names on the internet. 
	+ A Record: converts a domain name directly into an IP address. 
	+ CNAME: converts a domain name into another domain name. 
	+ Name Server (NS) Records: say which servers contain the DNS zone file for a domain. 


* Disaster Recovery: process of planning for and responding to events that can cause data loss or system downtime. 
	+ Disasters can be: natural (earthquake, flood) | artificial (cyber attack). 
	+ Consequences: financial loss, damage to reputation, legal issues. 
	+ A solid disaster recovery plan: 
		- Ensures business continuity. 
		- Minimizes downtime. 
		- Safeguards data integrity. 

// Managing a Disaster Recovery Site is very expensive, much maintenance, special skilled team needed. 
// Minimizes downtime, data loss. 
// Affordable, maintainable, reliable. 
* Elastic Disaster Recovery (DRS): fully managed for physical, virtual, cloud-based servers. 
	+ Source Servers: we want to replicate/protect. 
	+ Staging Area: location where AWS will receive the replicated data. 
	+ Launch Template: configure the specifications of recovery servers (size, region/subnet, SG). 
// Download and install AWS Replication Agent into on-prem server: source. 
// Cloud: { Stagin Subnet -> data replicated to EBS volumes. 
//            { Recovery Subnet: EC2. DISASTER!: Up within minutes, latest data. 
	+ Real-Time sync. 
	+ Automated drills. 
	+ Fail back after recovery. 


* Serverless Application Framework/Model (SAM): extension of CFN. Toolkit to simplify building/running serverless apps. 
	+ SAM Template: config file. Define infra. YAML | JSON. 
	+ CLI: init > build > local invoke > package > deploy  > logs > validate > publish. 
	+ Template is packaged with the app and uploaded to S3. 


* Timestream: fast, scalabale time-series DB.					// Time-Series DB: IoT: high volume of data in real-time. Evolving data sources. Data becoming less relevant over time. 
	+ Store & analize trillions of events per day. 
	+ Serverless. 
	+ Dynamic Schema. 
	+ Data Partition: indexes. 
	+ Data Lifecycle: in-mem store -> magnetic. 
	+ Custom Query Engine. 


* SES (Simple Email Service): 
	+ Verified Identities. 
	+ Config sets. 
	+ Dedicated IPs. 
	+ Email Receiving Info. 
	+ Use cases: 
		- Automate txn messages. 
		- Bulk email communication. 


* Simple Workflow Service: fully-managed State Tracker & Task Coordinator. 
	+ Workflow orchestration. 
	+ Task assignment and scheduling. 
	+ Use if I need external signals and/or launch child processes + return result. 
	+ Use cases: media processing, web app backends, business processes. 


* Managed Apache Airflow (MWAA): managed orchestration for Apache Airflow. 
	+ Simplified deployment & mgmt. 
	+ Scalable, perf optimization. 
	+ HA, fault tolerance. 
	+ Managed Control Plane. 


* EMR (Elastic Map-Reduce): sourcing data from a source (like S3) into a Big Data framework (Hadoo, Spark). 
	+ Cluster: collection of EC2 instances (nodes). 
	+ Primary Node: manages cluster. 
	+ Core Node: stores data in HDFS. 
	+ Task Node: data processing. 
	+ Add/remove nodes as I need. 



* X-Ray: tracing tool to analize/debug distributed apps. Collects data on requets made by the app & provides details + downstream calls. 
	+ Receives traces from AWS services. 
	+ Trace: represents a single request. A collection of segments. 
	+ Segment: represents a unit of data. 
	+ App has to be instrumented to send the traces. 



* Trusted Advisor: tool that provides real-time guidance to follow best practices. 
	+ Optimize Cost. 
	+ Performance. 
	+ Security. 
	+ Fault Tolerance (reliability). 
	+ Service Quotas. 




* Launch Wizard: deploy well-known 3rd party apps with pre-configured templates with ideal settings. 
	+ Choose app from catalog > Enter specifications > Get recommendations & cost estimate > Approve > Template gets created > Deployment. 



* Accounts: centralized Account mgmt, consolidated billing, SSO. 
	+ Service Control Policies (SCP): what users are allowed to do in an account. 			// What an entire account can do. 


* Control Tower: manage accounts. 								// Account orchestraror. 
	+ Landing Zone: foundation to quickly deploy accounts. 
	+ Guardrails: Preventive, Detective. 
	+ Account Factory: provisions account. 
	+ OU: Organizational Unit. 


* Systems Manager: manage servers. 
	+ Inventory of servers. 
	+ SSM Agent: runs on EC2, on-prem. Communicates with Systemas Manager. 
	+ Centralized Control. 
	+ Resource Grouping. 
	+ Automation. 
	+ Patch Management. 
	+ Operational Insights. 
	+ Config mgmt. 
	+ Remote mgmt. 
	+ Hybrid capabilities. 
	+ App management: 
		- App Manager. 
		- Parameter Store. 
	+ Change management: 
		- Change Manager. 
		- Automation: of IT tasks. 
		- Change Calendar. 
		- Maintenance Windows. 
	+ Node management: 
		- Compliance. 
		- Inventory. 
		- Session Manager. 
		- Run Command. 
		- State Manager. 
		- Patch Manager. 
		- Distributor. 
	+ Ops management: 
		- Incident Manager. 
		- OpsCenter. 


* License Manager: manage SW licenses. 
	+ Define License configs > Apply to resources > LM enforces rules > Tracking and reporting. 
	+ Centralized. 
	+ Cross-Account. 
	+ Discovery & reporting. 


* Proton: standardize app stack to create consistent envs. 
	+ Env Template. 
	+ Service Template. 
	+ Automated Deployments. 
	+ Flexible Definitions. 
	+ Proton Service Components. 
	+ Multi-Account. 



* Resource Group & Tag Manager: 
	+ Group resources based on tags. 


* Resilience Hub: centralized console where I can manage and automate: 
	+ Backup Schedules. 
	+ Recovery Point Objectives (RPO). 
	+ Recovery Time Objectives (RTO). 
	+ Continous Tracking. 
	+ Describe App & Resources > Define Resilience Policies > Run Assesments > Review > Implement Recommendations. 




* Resource Explorer: search & discovery of AWS resources, accross regions. 
	+ Admin. 
	+ User. 
	+ Index: collection of info about AWS resources in a region. 
		- Local. 
		- Aggregator. 




* Resource Access Manager (RAM): share resources accross accounts. 
	+ Create a resource > Select resources to share > Choose principals > Accept request at receiving account > Monitor. 



* Verified Permissions: manage permissions in my app. 



* Private Certificate Authority (CA): scalable, secure solution for managing private certs within an organization. 
	+ For internal communication in my company. 						// Not for the internet. 




* NACLs VS SGs:
	+ NACL (Netw Access Control List): layer of security for my VPC that acts as a subnet firewall. 
		- Can be associated with multiple subnets. 
		- Rules: 
			' #: priority. 
			' Proto: tcp/udp. 
			' Action: allow | deny. 
		- A new subnet is assigned a default NACL: ALL access allowed. 
		- Stateless. 								// Dumb, "naco". 
	+ Security Groups: virtual firewall for each invidual EC2 instance. 				// "Personal" security. 
		- Statefull. 
		- Allow only rules. Inbound | Outbound. 
		- Associate with multiple instances. 						// Example: "web servers". 
		- Associate 2 SG with a single EC2 instance, rules get merged. 
		- VPC-specific. 






* Security Lake: collects logs from multiple sources like on-prem, accounts, other cloud providers. 
	+ In S3 buckets. 
	+ Collect logs > Stored in S3 > Normalize into OCSF > Query. 






